<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   apuntes_typescript_parte_1
  </title>
 </head>
 <body>
  <h1 id="introduccion-a-typescript">
   Introducción a Typescript
  </h1>
  <div class="toc" id="table-of-contents">
   <h2 id="contents-header">
    Tabla de contenidos
   </h2>
   <ul class="toc">
    <li class="toc">
     <a class="toc" href="#setup-y-convenciones">
      Setup y convenciones
     </a>
    </li>
    <li class="toc">
     <a class="toc" href="#fundamentos-y-entorno-de-trabajo">
      Fundamentos y entorno de trabajo
     </a>
    </li>
    <li class="toc">
     <a class="toc" href="#documentacion-basica-de-estructuras-de-control-en-typescript">
      Documentación Básica de Estructuras de Control en TypeScript
     </a>
    </li>
    <li class="toc">
     <a class="toc" href="#construccion-de-tipos-type-vs-interface-narrowing-unionesintersecciones">
      Construcción de tipos: type vs interface, narrowing, uniones/intersecciones
     </a>
    </li>
   </ul>
  </div>
  <div class="chapter-container">
   <h2 id="setup-y-convenciones">
    Setup y convenciones
   </h2>
   <ul>
    <li>
     <strong>
      Requisitos
     </strong>
     : Node LTS (&gt;=18), npm (&gt;=9), editor con soporte TS (VS Code recomendado).
    </li>
    <li>
     <strong>
      Estructura base
     </strong>
     :
    </li>
   </ul>
   <div class="highlight language-bash">
    <pre><span></span><span class="w">  </span>npm<span class="w"> </span>init<span class="w"> </span>-y
<span class="w">  </span>npm<span class="w"> </span>i<span class="w"> </span>-D<span class="w"> </span>typescript<span class="w"> </span>@types/node<span class="w"> </span>ts-node
<span class="w">  </span>npx<span class="w"> </span>tsc<span class="w"> </span>--init<span class="w"> </span>--strict
<span class="w">  </span>mkdir<span class="w"> </span>src<span class="w"> </span>tests
<span class="w">  </span><span class="nb">echo</span><span class="w"> </span><span class="s2">"console.log('Hello TS');"</span><span class="w"> </span>&gt;<span class="w"> </span>src/index.ts
<span class="w">  </span>
</pre>
   </div>
   <ul>
    <li>
     <strong>
      Scripts iniciales
     </strong>
     (
     <code>
      package.json
     </code>
     ):
    </li>
   </ul>
   <div class="highlight language-json">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"module"</span><span class="p">,</span>
<span class="w">    </span><span class="nt">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">"dev"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ts-node src/index.ts"</span><span class="p">,</span>
<span class="w">      </span><span class="nt">"typecheck"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tsc --noEmit"</span><span class="p">,</span>
<span class="w">      </span><span class="nt">"build"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tsc -p tsconfig.json"</span><span class="p">,</span>
<span class="w">      </span><span class="nt">"start"</span><span class="p">:</span><span class="w"> </span><span class="s2">"node dist/index.js"</span><span class="p">,</span>
<span class="w">      </span><span class="nt">"clean"</span><span class="p">:</span><span class="w"> </span><span class="s2">"rimraf dist"</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span>
</pre>
    </div>
   </div>
  </div>
  <div class="chapter-container">
   <h2 id="fundamentos-y-entorno-de-trabajo">
    Fundamentos y entorno de trabajo
   </h2>
   <p>
    <strong>
     Objetivos
    </strong>
   </p>
   <ul>
    <li>
     Entender TS → JS, configuración mínima de
     <code>
      tsconfig.json
     </code>
     , inferencia y anotaciones de tipos.
    </li>
   </ul>
   <h3 id="1-teoria">
    1) Teoría
   </h3>
   <h4 id="11-que-es-typescript">
    1.1 ¿Qué es TypeScript?
   </h4>
   <ul>
    <li>
     <strong>
      Superset de JavaScript
     </strong>
     con
     <strong>
      tipado estático opcional
     </strong>
     .
    </li>
    <li>
     Se
     <strong>
      transpila
     </strong>
     (compila) a JavaScript estándar para ejecutarse en Node o el navegador.
    </li>
    <li>
     Beneficios: detección temprana de errores, autocompletado y refactors más seguros, documentación viva mediante tipos.
    </li>
   </ul>
   <h4 id="12-flujo-de-compilacion-ts-js">
    1.2 Flujo de compilación TS → JS
   </h4>
   <ol>
    <li>
     Editas archivos
     <code>
      .ts
     </code>
     en
     <code>
      src/
     </code>
     .
    </li>
    <li>
     El compilador
     <code>
      tsc
     </code>
     valida tipos y genera
     <code>
      .js
     </code>
     (por defecto en
     <code>
      dist/
     </code>
     ).
    </li>
    <li>
     Ejecutas el JS generado con Node (o sirves en el navegador).
    </li>
   </ol>
   <blockquote>
    <p>
     NOTA: En desarrollo podemos ejecutar TS directamente con utilidades como
     <code>
      ts-node
     </code>
     o
     <code>
      tsx
     </code>
     para iterar rápido.
    </p>
   </blockquote>
   <h4 id="13-tsconfigjson-minimos-clave">
    1.3
    <code>
     tsconfig.json
    </code>
    (mínimos clave)
   </h4>
   <ul>
    <li>
     <code>
      target
     </code>
     : versión de JS a generar (p. ej.,
     <code>
      ES2022
     </code>
     ).
    </li>
    <li>
     <code>
      module
     </code>
     : sistema de módulos de salida (p. ej.,
     <code>
      ESNext
     </code>
     o
     <code>
      CommonJS
     </code>
     ).
    </li>
    <li>
     <code>
      strict
     </code>
     : activa el modo estricto (recomendado).
    </li>
    <li>
     <code>
      outDir
     </code>
     : carpeta de salida (p. ej.,
     <code>
      dist
     </code>
     ).
    </li>
    <li>
     <code>
      moduleResolution
     </code>
     : cómo se resuelven importaciones (p. ej.,
     <code>
      Bundler
     </code>
     ,
     <code>
      Node
     </code>
     ).
    </li>
    <li>
     <code>
      include
     </code>
     : qué carpetas/archivos compilar (p. ej.,
     <code>
      src
     </code>
     ).
    </li>
   </ul>
   <h4 id="14-tipos-basicos-y-especiales">
    1.4 Tipos básicos y especiales
   </h4>
   <ul>
    <li>
     <strong>
      Primitivos
     </strong>
     :
     <code>
      string
     </code>
     ,
     <code>
      number
     </code>
     ,
     <code>
      boolean
     </code>
     .
    </li>
    <li>
     <strong>
      Especiales
     </strong>
     :
     <code>
      null
     </code>
     ,
     <code>
      undefined
     </code>
     ,
     <code>
      void
     </code>
     (retorno de funciones sin valor).
    </li>
    <li>
     <strong>
      <code>
       any
      </code>
     </strong>
     : desactiva el chequeo de tipos (evitar salvo migraciones).
    </li>
    <li>
     <strong>
      <code>
       unknown
      </code>
     </strong>
     : dato de tipo desconocido que
     <strong>
      obliga
     </strong>
     a validar antes de usar.
    </li>
    <li>
     <strong>
      <code>
       never
      </code>
     </strong>
     : funciones que nunca retornan (p. ej., lanzan error) o código inalcanzable.
    </li>
   </ul>
   <h4 id="15-inferencia-anotaciones-y-aserciones">
    1.5 Inferencia, anotaciones y aserciones
   </h4>
   <ul>
    <li>
     <strong>
      Inferencia
     </strong>
     : TS deduce el tipo a partir del valor asignado.
    </li>
   </ul>
   <div class="highlight language-ts">
    <pre><span></span><span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">42</span><span class="p">;</span><span class="w"> </span><span class="c1">// number inferido</span>
<span class="w">  </span>
</pre>
   </div>
   <ul>
    <li>
     <strong>
      Anotación
     </strong>
     : declaras el tipo explícitamente.
    </li>
   </ul>
   <div class="highlight language-ts">
    <pre><span></span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Ada"</span><span class="p">;</span>
<span class="w">  </span>
</pre>
   </div>
   <ul>
    <li>
     <p>
      <strong>
       Aserciones
      </strong>
      (no cambian el valor, solo dicen a TS cómo tratarlo):
     </p>
    </li>
    <li>
     <p>
      <code>
       as Tipo
      </code>
      y
      <code>
       &lt;&gt;
      </code>
      (en TSX se usa solo
      <code>
       as
      </code>
      ),
     </p>
    </li>
    <li>
     <code>
      as const
     </code>
     (vuelve literal/readonly),
    </li>
    <li>
     <strong>
      non-null assertion
     </strong>
     <code>
      !
     </code>
     (afirma que no es
     <code>
      null
     </code>
     /
     <code>
      undefined
     </code>
     , usar con moderación).
    </li>
   </ul>
   <div class="highlight language-ts">
    <pre><span></span><span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">el</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"app"</span><span class="p">);</span>
<span class="w">  </span><span class="nx">el</span><span class="o">!</span><span class="p">.</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Hola"</span><span class="p">;</span><span class="w"> </span><span class="c1">// ¡solo si estás seguro de que existe!</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"ok"</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="kd">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// tipo "ok", no string genérico</span>
<span class="w">  </span>
</pre>
   </div>
   <h4 id="16-tipado-estructural-idea-clave">
    1.6 Tipado estructural (idea clave)
   </h4>
   <p>
    <strong>
     ¿Qué es el Tipado Estructural?
    </strong>
    El principio fundamental del sistema de tipos de
    <em>
     TypeScript
    </em>
    es el tipado estructural, a veces llamado
    <em>
     "duck typing"
    </em>
    ("si camina como un pato y grazna como un pato, entonces debe ser un pato"). Esto significa que
    <em>
     TypeScript
    </em>
    no se fija en el nombre del tipo o en si fue explícitamente declarado de cierta manera, sino en la estructura o forma que tienen los datos. Al comparar dos tipos,
    <em>
     TypeScript
    </em>
    solo considera los miembros (propiedades y métodos) que contienen.
   </p>
   <ul>
    <li>
     TS compara
     <strong>
      formas
     </strong>
     (propiedades/métodos) de los objetos, no sus nombres de tipo.
    </li>
    <li>
     Si dos objetos tienen la misma estructura requerida, son compatibles.
    </li>
   </ul>
   <div class="highlight language-ts">
    <pre><span></span><span class="kr">type</span><span class="w"> </span><span class="nx">Persona</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">};</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">usuario</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="s2">"Ana"</span><span class="p">,</span><span class="w"> </span><span class="nx">edad</span><span class="o">:</span><span class="w"> </span><span class="kt">20</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// OK: usuario tiene al menos { nombre: string }</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">p</span><span class="o">:</span><span class="w"> </span><span class="kt">Persona</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">usuario</span><span class="p">;</span>

<span class="c1">// ERROR (excess property check): literal con extra "edad" directamente a Persona</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">p2</span><span class="o">:</span><span class="w"> </span><span class="kt">Persona</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="s2">"Ana"</span><span class="p">,</span><span class="w"> </span><span class="nx">edad</span><span class="o">:</span><span class="w"> </span><span class="kt">20</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// ❌</span>
</pre>
   </div>
   <blockquote>
    <p>
     <strong>
      ¿Por qué es correcto?
      <code>
       const p: Persona = usuario;
      </code>
     </strong>
     Aquí se aplica el tipado estructural en su forma más pura.
*   El tipo
     <code>
      Persona
     </code>
     exige que cualquier objeto compatible tenga una propiedad
     <code>
      nombre
     </code>
     de tipo
     <code>
      string
     </code>
     .
*   La variable
     <code>
      usuario
     </code>
     es un objeto que tiene la propiedad
     <code>
      nombre
     </code>
     (y además la propiedad
     <code>
      edad
     </code>
     ).
*   Como
     <code>
      usuario
     </code>
     cumple con la "forma" mínima requerida por
     <code>
      Persona
     </code>
     (tiene un
     <code>
      nombre
     </code>
     ), la asignación es válida. TypeScript simplemente ignora la propiedad adicional
     <code>
      edad
     </code>
     .
Esta flexibilidad es muy potente, ya que permite que los objetos contengan más información de la requerida por un tipo sin generar errores.
Sin embargo, la asignación con arror (Chequeo de Propiedades Excesivas)
    </p>
    <p>
     <strong>
      ¿Por qué es incorrecto?
      <code>
       const p2: Persona = { nombre: "Ana", edad: 20 };
      </code>
     </strong>
     A primera vista, esto parece inconsistente con el ejemplo anterior. Sin embargo, TypeScript aplica una regla más estricta llamada "chequeo de propiedades excesivas" cuando se asigna un objeto literal (un objeto definido directamente en el lugar de la asignación) a una variable con un tipo explícito.
El razonamiento de TypeScript es el siguiente:
* Cuando creas un objeto literal y lo asignas directamente, es muy probable que tu intención sea que ese objeto se ajuste exactamente a la forma del tipo. Las propiedades adicionales suelen ser errores tipográficos o malentendidos sobre la estructura del tipo. En este caso:
Estás creando un objeto
     <code>
      { nombre: "Ana", edad: 20 }
     </code>
     y asignándolo de inmediato a una variable de tipo
     <code>
      Persona
     </code>
     .
     <em>
      TypeScript
     </em>
     detecta que el objeto literal tiene una propiedad edad que no está definida en el tipo Persona.
Para ayudarte a detectar un posible error, te avisa con un mensaje que indica que la propiedad edad no existe en el tipo
     <code>
      Persona
     </code>
     .
Esta verificación especial solo se activa para
     <strong>
      objetos literales
     </strong>
     , lo que explica por qué el primer ejemplo, que utiliza una variable intermedia (usuario), sí funciona.
    </p>
   </blockquote>
   <hr/>
   <h3 id="2-parte-practica">
    2) Parte práctica
   </h3>
   <h4 id="21-preparacion-del-proyecto">
    2.1 Preparación del proyecto
   </h4>
   <div class="highlight language-bash">
    <pre><span></span>npm<span class="w"> </span>init<span class="w"> </span>-y
npm<span class="w"> </span>i<span class="w"> </span>-D<span class="w"> </span>typescript<span class="w"> </span>@types/node<span class="w"> </span>ts-node
npx<span class="w"> </span>tsc<span class="w"> </span>--init<span class="w"> </span>--strict
mkdir<span class="w"> </span>src
<span class="nb">printf</span><span class="w"> </span><span class="s2">"console.log('Hello TS');</span>
<span class="s2">"</span><span class="w"> </span>&gt;<span class="w"> </span>src/index.ts
</pre>
   </div>
   <p>
    <strong>
     Scripts
    </strong>
    en
    <code>
     package.json
    </code>
    (añade dentro de
    <code>
     scripts
    </code>
    ):
   </p>
   <div class="highlight language-json">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">"dev"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ts-node src/index.ts"</span><span class="p">,</span>
<span class="w">  </span><span class="nt">"typecheck"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tsc --noEmit"</span><span class="p">,</span>
<span class="w">  </span><span class="nt">"build"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tsc -p tsconfig.json"</span><span class="p">,</span>
<span class="w">  </span><span class="nt">"start"</span><span class="p">:</span><span class="w"> </span><span class="s2">"node dist/index.js"</span><span class="p">,</span>
<span class="w">  </span><span class="nt">"watch"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tsc -w"</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <h4 id="22-ejecucion-rapida">
    2.2 Ejecución rápida
   </h4>
   <div class="highlight language-bash">
    <pre><span></span>npm<span class="w"> </span>run<span class="w"> </span>dev<span class="w">        </span><span class="c1"># Ejecuta TS directamente (ts-node)</span>
npm<span class="w"> </span>run<span class="w"> </span>typecheck<span class="w">  </span><span class="c1"># Verifica tipos sin emitir JS</span>
npm<span class="w"> </span>run<span class="w"> </span>build<span class="w">      </span><span class="c1"># Emite JS a dist/</span>
node<span class="w"> </span>dist/index.js<span class="w"> </span><span class="c1"># Ejecuta salida compilada</span>
</pre>
   </div>
   <h4 id="23-archivo-de-ejercicios-src01-typests">
    2.3 Archivo de ejercicios
    <code>
     src/01-types.ts
    </code>
   </h4>
   <p>
    Incluye ejemplos de cada concepto:
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="c1">// 1) Inferencia vs anotación</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">anio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2025</span><span class="p">;</span><span class="w">            </span><span class="c1">// number inferido</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">curso</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"TS"</span><span class="p">;</span><span class="w">     </span><span class="c1">// anotación explícita</span>

<span class="c1">// 2) any vs unknown</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="kt">any</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s2">"{}"</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">u</span><span class="o">:</span><span class="w"> </span><span class="kt">unknown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s2">"{\"n\":1}"</span><span class="p">);</span>
<span class="c1">// a.n.toFixed();           // OK en tiempo de tipos (peligroso)</span>
<span class="c1">// (u as { n: number }).n.toFixed(); // validar/asertar antes</span>

<span class="c1">// 3) never</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">fail</span><span class="p">(</span><span class="nx">msg</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">never</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 4) as const y non-null assertion</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">estado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"ok"</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="kd">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// tipo literal "ok"</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"app"</span><span class="p">);</span>
<span class="c1">// root!.textContent = estado; // usar ! solo si estás seguro</span>

<span class="c1">// 5) Tipado estructural (ejemplo simple)</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Persona</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"> </span><span class="nx">edad</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">};</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="s2">"Ada"</span><span class="p">,</span><span class="w"> </span><span class="nx">edad</span><span class="o">:</span><span class="w"> </span><span class="kt">36</span><span class="p">,</span><span class="w"> </span><span class="nx">extra</span><span class="o">:</span><span class="w"> </span><span class="kt">true</span><span class="w"> </span><span class="p">};</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">q</span><span class="o">:</span><span class="w"> </span><span class="kt">Persona</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">p</span><span class="p">;</span><span class="w"> </span><span class="c1">// compatible por forma</span>
</pre>
    </div>
   </div>
   <p>
    1) Inferencia vs anotación
   </p>
   <p>
    <strong>
     Idea
    </strong>
    : TS infere tipos a partir del valor. Anotá solo cuando el tipo no sea obvio o lo quieras restringir.
   </p>
   <p>
    <strong>
     Regla mental
    </strong>
    : Preferí inferencia; anota si la API pública o el contrato lo requieren.
   </p>
   <p>
    <strong>
     Trampa
    </strong>
    : anotar de más puede “encorsetar” y forzar as innecesarios.
   </p>
   <p>
    2)
    <code>
     any
    </code>
    vs
    <code>
     unknown&lt;pre class="empty-code-block"&gt;
&lt;/pre&gt;any
    </code>
    : “apaga” el chequeo de tipos. Propaga incertidumbre y permite cualquier operación → peligroso.
   </p>
   <p>
    <code>
     unknown
    </code>
    : “no sé qué es todavía”; obliga a narrowing/validación antes de usar.
   </p>
   <p>
    La principal diferencia entre
    <code>
     any
    </code>
    y
    <code>
     unknown
    </code>
    en TypeScript radica en la
    <strong>
     seguridad de tipos
    </strong>
    :
    <code>
     unknown
    </code>
    es la alternativa segura a
    <code>
     any
    </code>
    .
   </p>
   <p>
    Para entenderlo mejor, desglosemos sus características y comparémoslas.
   </p>
   <hr/>
   <p>
    <strong>
     El Tipo
     <code>
      any
     </code>
     : La Vía de Escape (Insegura)
    </strong>
   </p>
   <p>
    Cuando declaras una variable con el tipo
    <code>
     any
    </code>
    , básicamente le dices al compilador de
    <em>
     TypeScript
    </em>
    : "No te preocupes por esta variable, yo sé lo que hago".
   </p>
   <ul>
    <li>
     <strong>
      Desactiva la verificación de tipos
     </strong>
     :
     <code>
      any
     </code>
     elimina todas las ventajas de seguridad que ofrece TypeScript para esa variable.
    </li>
    <li>
     <strong>
      Permite cualquier operación
     </strong>
     : Puedes acceder a cualquier propiedad, llamar a cualquier método o realizar cualquier operación sobre una variable de tipo
     <code>
      any
     </code>
     sin que TypeScript genere un error en tiempo de compilación, incluso si esa operación es incorrecta y causará un error en tiempo de ejecución.
    </li>
    <li>
     <strong>
      Se puede asignar a cualquier otro tipo
     </strong>
     : Una variable
     <code>
      any
     </code>
     puede ser asignada a una variable de cualquier otro tipo (
     <code>
      string
     </code>
     ,
     <code>
      number
     </code>
     , etc.), lo cual puede "contaminar" tu código y ocultar errores.
    </li>
   </ul>
   <p>
    <strong>
     Ejemplo con
     <code>
      any
     </code>
     :
    </strong>
   </p>
   <div class="highlight language-typescript">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">valor</span><span class="o">:</span><span class="w"> </span><span class="kt">any</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Hola Mundo"</span><span class="p">;</span>

<span class="c1">// No hay errores en tiempo de compilación...</span>
<span class="nx">valor</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span><span class="w"> </span><span class="c1">// Funciona, valor es un string</span>
<span class="nx">valor</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mf">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ¡ERROR en tiempo de ejecución! toFixed no existe en string.</span>
<span class="w">                  </span><span class="c1">// TypeScript no te advierte.</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">numero</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>
<span class="nx">numero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">valor</span><span class="p">;</span><span class="w"> </span><span class="c1">// No hay error, aunque 'valor' sea un string.</span>
</pre>
    </div>
   </div>
   <p>
    <strong>
     Cuándo usar
     <code>
      any
     </code>
     :
    </strong>
    Su uso debe ser muy limitado. Es principalmente útil durante la migración de un proyecto de JavaScript a TypeScript o al interactuar con bibliotecas de terceros que no tienen tipos definidos.
   </p>
   <p>
    <strong>
     El Tipo
     <code>
      unknown
     </code>
     : La Alternativa Segura
    </strong>
   </p>
   <p>
    <code>
     unknown
    </code>
    también te permite asignar cualquier tipo de valor a una variable. La gran diferencia es lo que te permite hacer
    <em>
     después
    </em>
    .
    <code>
     unknown
    </code>
    te obliga a verificar el tipo de la variable antes de poder realizar cualquier operación sobre ella.
   </p>
   <ul>
    <li>
     <strong>
      Mantiene la seguridad de tipos
     </strong>
     : A diferencia de
     <code>
      any
     </code>
     ,
     <code>
      unknown
     </code>
     no te deja realizar operaciones arbitrarias.
    </li>
    <li>
     <strong>
      No permite operaciones sin verificación
     </strong>
     : TypeScript te mostrará un error si intentas acceder a propiedades o llamar a métodos en una variable
     <code>
      unknown
     </code>
     .
    </li>
    <li>
     <strong>
      No se puede asignar a otros tipos (sin validación)
     </strong>
     : No puedes asignar una variable
     <code>
      unknown
     </code>
     a una variable con un tipo específico (
     <code>
      string
     </code>
     ,
     <code>
      number
     </code>
     , etc.) a menos que primero confirmes su tipo mediante una comprobación.
    </li>
   </ul>
   <p>
    Para trabajar con un valor
    <code>
     unknown
    </code>
    , debes "estrechar" (narrow) su tipo usando:
*
    <strong>
     Protectores de tipo (Type Guards)
    </strong>
    : como
    <code>
     typeof
    </code>
    ,
    <code>
     instanceof
    </code>
    .
*
    <strong>
     Aserciones de tipo (Type Assertions)
    </strong>
    : usando la palabra clave
    <code>
     as
    </code>
    .
   </p>
   <p>
    <strong>
     Ejemplo con
     <code>
      unknown
     </code>
     :
    </strong>
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">valor</span><span class="o">:</span><span class="w"> </span><span class="kt">unknown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"Hola Mundo"</span><span class="p">;</span>

<span class="c1">// ERROR: 'valor' es de tipo 'unknown'.</span>
<span class="c1">// valor.toUpperCase(); // ❌ TypeScript te detiene aquí.</span>

<span class="c1">// Forma correcta: verificar el tipo primero</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="ow">typeof</span><span class="w"> </span><span class="nx">valor</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">'string'</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Dentro de este bloque, TypeScript sabe que 'valor' es un string</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">valor</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span><span class="w"> </span><span class="c1">// ✅ Correcto</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">texto</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="c1">// ERROR: El tipo 'unknown' no se puede asignar al tipo 'string'.</span>
<span class="c1">// texto = valor; // ❌</span>

<span class="c1">// Forma correcta: usar aserción después de verificar</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="ow">typeof</span><span class="w"> </span><span class="nx">valor</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">'string'</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">texto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">valor</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅ Correcto</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <p>
    <strong>
     Tabla Comparativa:
     <code>
      any
     </code>
     vs.
     <code>
      unknown
     </code>
    </strong>
   </p>
   <table>
    <thead>
     <tr>
      <th style="text-align: left;">
       Característica
      </th>
      <th style="text-align: left;">
       <code>
        any
       </code>
      </th>
      <th style="text-align: left;">
       <code>
        unknown
       </code>
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td style="text-align: left;">
       <strong>
        Asignar cualquier valor
       </strong>
      </td>
      <td style="text-align: left;">
       ✅ Sí
      </td>
      <td style="text-align: left;">
       ✅ Sí
      </td>
     </tr>
     <tr>
      <td style="text-align: left;">
       <strong>
        Seguridad de tipos
       </strong>
      </td>
      <td style="text-align: left;">
       ❌ No (desactiva el chequeo)
      </td>
      <td style="text-align: left;">
       ✅ Sí (obliga a chequear)
      </td>
     </tr>
     <tr>
      <td style="text-align: left;">
       <strong>
        Acceder a propiedades
       </strong>
      </td>
      <td style="text-align: left;">
       ✅ Sí (sin verificación)
      </td>
      <td style="text-align: left;">
       ❌ No (requiere verificación)
      </td>
     </tr>
     <tr>
      <td style="text-align: left;">
       <strong>
        Asignar a otros tipos
       </strong>
      </td>
      <td style="text-align: left;">
       ✅ Sí
      </td>
      <td style="text-align: left;">
       ❌ No (requiere verificación)
      </td>
     </tr>
     <tr>
      <td style="text-align: left;">
       <strong>
        Caso de uso principal
       </strong>
      </td>
      <td style="text-align: left;">
       Migración de JS, librerías sin tipos.
      </td>
      <td style="text-align: left;">
       Datos de fuentes externas (APIs, formularios).
      </td>
     </tr>
     <tr>
      <td style="text-align: left;">
       <strong>
        Regla mental
       </strong>
       : Si viene de JSON o input externo, usa unknown y valida.
      </td>
      <td style="text-align: left;">
      </td>
      <td style="text-align: left;">
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    <strong>
     Patrón
    </strong>
    : type guards, zod, in, typeof, Array.isArray, etc.
   </p>
   <hr/>
   <p>
    3)
    <code>
     never
    </code>
    :
    <strong>
     (el arte de manejar lo imposible)
    </strong>
   </p>
   <p>
    El tipo
    <code>
     never
    </code>
    representa un valor que
    <strong>
     nunca debería ocurrir
    </strong>
    . No es
    <code>
     void
    </code>
    (que significa que una función no retorna un valor), sino que indica que la función
    <strong>
     jamás termina su ejecución normal
    </strong>
    .
   </p>
   <p>
    Esto sucede principalmente en dos casos:
   </p>
   <p>
    a.  Una función que siempre lanza un error (
    <code>
     throw new Error(...)
    </code>
    ).
   </p>
   <p>
    b.  Una función que contiene un bucle infinito (
    <code>
     while (true) {}
    </code>
    ).
   </p>
   <p>
    <strong>
     Su uso más importante: Garantizar la exhaustividad
    </strong>
   </p>
   <p>
    La verdadera magia de
    <code>
     never
    </code>
    aparece al usarlo con uniones discriminadas para asegurar que has manejado todos los casos posibles en un
    <code>
     switch
    </code>
    o
    <code>
     if/else
    </code>
    .
   </p>
   <p>
    <strong>
     La técnica es simple
    </strong>
    : en el bloque
    <code>
     default
    </code>
    (o el
    <code>
     else
    </code>
    final), intentas asignar la variable a un tipo
    <code>
     never
    </code>
    . Si has cubierto todos los casos,
    <em>
     Typescript
    </em>
    sabe que ese bloque es inalcanzable y el código es válido. Si olvidas un caso, el código dará un error.
   </p>
   <p>
    <strong>
     Ejemplo Práctico:
    </strong>
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="kr">type</span><span class="w"> </span><span class="nx">Estado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"cargando"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">"exito"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">"error"</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">manejarEstado</span><span class="p">(</span><span class="nx">estado</span><span class="o">:</span><span class="w"> </span><span class="kt">Estado</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="nx">estado</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s2">"cargando"</span><span class="o">:</span>
<span class="w">      </span><span class="c1">// ... lógica para cargando</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s2">"exito"</span><span class="o">:</span>
<span class="w">      </span><span class="c1">// ... lógica para éxito</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// OLVIDAMOS MANEJAR EL CASO "error" INTENCIONADAMENTE</span>
<span class="w">  </span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="c1">// TypeScript ve que 'estado' aquí SÓLO puede ser "error".</span>
<span class="w">      </span><span class="c1">// Intentar asignarlo a 'never' causa un error de compilación.</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">casoImposible</span><span class="o">:</span><span class="w"> </span><span class="kt">never</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">estado</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ Error: El tipo 'string' ("error") no se puede asignar al tipo 'never'.</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <p>
    <strong>
     Regla Mental:
    </strong>
    Piensa en
    <code>
     never
    </code>
    como una afirmación. Al usarlo, le dices a
    <em>
     Typescript
    </em>
    : "Estoy seguro de que esta parte del código nunca se ejecutará". Si te equivocas (porque olvidaste un caso),
    <em>
     Typescript
    </em>
    te lo señalará con un error, salvándote de futuros bugs.
   </p>
   <p>
    4)
    <code>
     as const
    </code>
    y
    <code>
     non-null assertion
    </code>
    (!)
   </p>
   <p>
    <code>
     as const
    </code>
    : Convierte valores a literales y propiedades a readonly. Evita el “widening” ("ok" en vez de string, 1 en vez de number).
   </p>
   <p>
    Útil para discriminantes, config y tuplas.
   </p>
   <p>
    <code>
     ! non-null
    </code>
    : Le decís a TS “sé que no es null/undefined”. No chequeará en runtime.
   </p>
   <p>
    <strong>
     Regla mental
    </strong>
    : úsalo solo si realmente podés garantizarlo; preferí narrowing u opcional encadenado.
   </p>
   <p>
    5) Tipado estructural
   </p>
   <p>
    <strong>
     Idea clave
    </strong>
    : compatibilidad por forma, no por nombre. Si un objeto contiene lo que el tipo pide, es asignable.
   </p>
   <p>
    <strong>
     Extra fields
    </strong>
    : no molestan salvo en excess property checks con literales directos.
   </p>
   <p>
    <strong>
     Regla mental
    </strong>
    : A → B si A tiene al menos las props de B con tipos compatibles.
   </p>
   <p>
    <strong>
     Ejecuta
    </strong>
    :
   </p>
   <div class="highlight language-bash">
    <pre><span></span>npm<span class="w"> </span>run<span class="w"> </span>dev
npm<span class="w"> </span>run<span class="w"> </span>typecheck
</pre>
   </div>
   <h4 id="ejercicios-opcionales">
    Ejercicios opcionales
   </h4>
   <ol>
    <li>
     <strong>
      Inferencia
     </strong>
     : declara 5 constantes con valores variados y describe qué tipo infiere TS.
    </li>
    <li>
     <strong>
      <code>
       unknown
      </code>
      vs
      <code>
       any
      </code>
     </strong>
     : crea una función
     <code>
      parseoSeguro
     </code>
     que reciba
     <code>
      unknown
     </code>
     y devuelva un número validado o lance error.
    </li>
    <li>
     <strong>
      Aserciones
     </strong>
     : convierte un objeto a literal con
     <code>
      as const
     </code>
     y verifica que sea
     <code>
      readonly
     </code>
     .
    </li>
    <li>
     <strong>
      <code>
       never
      </code>
     </strong>
     : implementa una función
     <code>
      exhaustiveCheck(x: never): never
     </code>
     y úsala en un
     <code>
      switch
     </code>
     (simulación;
     <em>
      narrowing
     </em>
     se ve la sem 2).
    </li>
    <li>
     <strong>
      Build
     </strong>
     : compila con
     <code>
      npm run build
     </code>
     y sube
     <code>
      dist/
     </code>
     al
     <code>
      .gitignore
     </code>
     .
    </li>
   </ol>
   <h3 id="3-preguntas-frecuentes">
    3) Preguntas frecuentes
   </h3>
   <ul>
    <li>
     <strong>
      ¿
      <code>
       any
      </code>
      es malo?
     </strong>
     No siempre, pero reduce garantías. Prefiere
     <code>
      unknown
     </code>
     + validación.
    </li>
    <li>
     <strong>
      ¿Debo tipar todo?
     </strong>
     No. Confía en la
     <strong>
      inferencia
     </strong>
     cuando el valor es claro.
    </li>
    <li>
     <strong>
      ¿Cuándo usar
      <code>
       !
      </code>
      ?
     </strong>
     Solo si has verificado la existencia por otra vía (p. ej., en HTML está el elemento). Úsalo con moderación.
    </li>
   </ul>
  </div>
  <div class="chapter-container">
   <h2 id="documentacion-basica-de-estructuras-de-control-en-typescript">
    Documentación Básica de Estructuras de Control en TypeScript
   </h2>
   <p>
    TypeScript, al ser un superconjunto de JavaScript, comparte sus estructuras de control de flujo. Estas estructuras te permiten dirigir la ejecución de tu programa basándose en condiciones, repitiendo acciones y manejando errores.
   </p>
   <h3 id="1-condicionales-toma-de-decisiones">
    1. Condicionales: Toma de Decisiones
   </h3>
   <p>
    Los condicionales ejecutan bloques de código solo si se cumplen ciertas condiciones.
   </p>
   <h4 id="if-else-else-if">
    <code>
     if / else / else if
    </code>
   </h4>
   <p>
    Es la estructura condicional más básica. Evalúa una condición y ejecuta un bloque de código si es verdadera. Opcionalmente, puede tener bloques
    <code>
     else if
    </code>
    para evaluar condiciones adicionales y un bloque
    <code>
     else
    </code>
    final que se ejecuta si ninguna de las condiciones anteriores es verdadera.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">temperatura</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">25</span><span class="p">;</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">temperatura</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">30</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hace mucho calor."</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">temperatura</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">20</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"El clima es agradable."</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hace frío."</span><span class="p">);</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <h4 id="switch">
    <code>
     switch
    </code>
   </h4>
   <p>
    Es útil cuando se necesita comparar una sola variable contra múltiples valores posibles. Es una alternativa más limpia a una cadena larga de
    <code>
     if/else if
    </code>
    .
   </p>
   <p>
    Cada
    <code>
     case
    </code>
    se compara con el valor de la variable. La declaración
    <code>
     break
    </code>
    es crucial para salir del
    <code>
     switch
    </code>
    una vez que se encuentra una coincidencia. El bloque
    <code>
     default
    </code>
    es opcional y se ejecuta si ningún
    <code>
     case
    </code>
    coincide.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="kr">type</span><span class="w"> </span><span class="nx">NivelUsuario</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"admin"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">"editor"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">"visitante"</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">nivel</span><span class="o">:</span><span class="w"> </span><span class="kt">NivelUsuario</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"admin"</span><span class="p">;</span>

<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="nx">nivel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="s2">"admin"</span><span class="o">:</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Acceso total."</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="s2">"editor"</span><span class="o">:</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Puede editar contenido."</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="s2">"visitante"</span><span class="o">:</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Solo puede ver el contenido."</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="nx">default</span><span class="o">:</span>
<span class="w">    </span><span class="kt">console.log</span><span class="p">(</span><span class="s2">"Nivel de usuario no reconocido."</span><span class="p">);</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <h3 id="2-bucles-ejecucion-repetitiva">
    2. Bucles: Ejecución Repetitiva
   </h3>
   <p>
    Los bucles te permiten ejecutar un bloque de código múltiples veces.
   </p>
   <h4 id="for">
    <code>
     for
    </code>
   </h4>
   <p>
    El bucle
    <code>
     for
    </code>
    tradicional es ideal cuando sabes de antemano cuántas veces quieres que se repita el bucle. Consta de tres partes: una inicialización, una condición y una expresión de incremento/decremento.
   </p>
   <div class="highlight language-ts">
    <pre><span></span><span class="c1">// Imprime los números del 0 al 4</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">5</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>
</pre>
   </div>
   <h4 id="forof">
    <code>
     for...of
    </code>
   </h4>
   <p>
    Este bucle itera sobre los valores de objetos iterables como arrays, strings, Sets o Maps. Es la forma más moderna y legible de recorrer los elementos de una colección.
   </p>
   <div class="highlight language-ts">
    <pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">frutas</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">"manzana"</span><span class="p">,</span><span class="w"> </span><span class="s2">"banana"</span><span class="p">,</span><span class="w"> </span><span class="s2">"cereza"</span><span class="p">];</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">fruta</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">frutas</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fruta</span><span class="p">);</span>
<span class="p">}</span>
</pre>
   </div>
   <h4 id="forin">
    <code>
     for...in
    </code>
   </h4>
   <p>
    Este bucle itera sobre las claves (o propiedades enumerables) de un objeto.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">usuario</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="s2">"Ana"</span><span class="p">,</span>
<span class="w">  </span><span class="nx">edad</span><span class="o">:</span><span class="w"> </span><span class="kt">30</span>
<span class="p">};</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">clave</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">usuario</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">clave</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="nx">usuario</span><span class="p">[</span><span class="nx">clave</span><span class="p">]</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <h4 id="while">
    <code>
     while
    </code>
   </h4>
   <p>
    El bucle
    <code>
     while
    </code>
    ejecuta un bloque de código mientras una condición especificada sea verdadera. La condición se evalúa
    <em>
     antes
    </em>
    de cada iteración.
   </p>
   <div class="highlight language-ts">
    <pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">contador</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span>

<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">contador</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hola"</span><span class="p">);</span>
<span class="w">  </span><span class="nx">contador</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre>
   </div>
   <h4 id="dowhile">
    <code>
     do...while
    </code>
   </h4>
   <p>
    Es similar al bucle
    <code>
     while
    </code>
    , pero con una diferencia clave: la condición se evalúa
    <em>
     después
    </em>
    de ejecutar el bloque de código. Esto garantiza que el bloque se ejecute al menos una vez.
   </p>
   <div class="highlight language-ts">
    <pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">numero</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5</span><span class="p">;</span>

<span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Este mensaje se muestra al menos una vez."</span><span class="p">);</span>
<span class="w">  </span><span class="nx">numero</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">numero</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">5</span><span class="p">);</span>
</pre>
   </div>
   <h3 id="3-control-de-bucles">
    3. Control de Bucles
   </h3>
   <p>
    Estas declaraciones te permiten alterar el flujo normal de un bucle.
   </p>
   <h4 id="break">
    <code>
     break
    </code>
   </h4>
   <p>
    Termina la ejecución del bucle actual (o
    <code>
     switch
    </code>
    ) de forma inmediata y transfiere el control a la siguiente instrucción después del bucle.
   </p>
   <div class="highlight language-ts">
    <pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">10</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">5</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="c1">// El bucle se detiene cuando i es 5</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span><span class="w"> </span><span class="c1">// Imprimirá de 0 a 4</span>
<span class="p">}</span>
</pre>
   </div>
   <h4 id="continue">
    <code>
     continue
    </code>
   </h4>
   <p>
    Omite el resto del código en la iteración actual y pasa directamente a la siguiente iteración del bucle.
   </p>
   <div class="highlight language-ts">
    <pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">5</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">continue</span><span class="p">;</span><span class="w"> </span><span class="c1">// Se salta la iteración donde i es 2</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span><span class="w"> </span><span class="c1">// Imprimirá 0, 1, 3, 4</span>
<span class="p">}</span>
</pre>
   </div>
   <h3 id="4-manejo-de-errores">
    4. Manejo de Errores
   </h3>
   <p>
    Permite manejar errores de tiempo de ejecución de una manera controlada.
   </p>
   <h4 id="try-catch-finally">
    <code>
     try / catch / finally
    </code>
   </h4>
   <ul>
    <li>
     <strong>
      <code>
       try
      </code>
     </strong>
     : Encierra el código que podría lanzar una excepción.
    </li>
    <li>
     <strong>
      <code>
       catch
      </code>
     </strong>
     : Captura y maneja la excepción si ocurre una en el bloque
     <code>
      try
     </code>
     .
    </li>
    <li>
     <strong>
      <code>
       finally
      </code>
     </strong>
     : Este bloque se ejecuta siempre, independientemente de si se lanzó una excepción o no. Es útil para limpiar recursos.
    </li>
   </ul>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Intenta ejecutar un código que puede fallar</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="nx">resultado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s2">"{'nombre': 'Juan', 'edad': 30}"</span><span class="p">);</span><span class="w"> </span><span class="c1">// JSON inválido</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">resultado</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Este bloque se ejecuta si hay un error en el 'try'</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s2">"Ocurrió un error al procesar el JSON:"</span><span class="p">,</span><span class="w"> </span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Este bloque se ejecuta siempre</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"La operación ha finalizado."</span><span class="p">);</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
  </div>
  <div class="chapter-container">
   <h2 id="construccion-de-tipos-type-vs-interface-narrowing-unionesintersecciones">
    Construcción de tipos:
    <code>
     type
    </code>
    vs
    <code>
     interface
    </code>
    ,
    <em>
     narrowing
    </em>
    , uniones/intersecciones
   </h2>
   <p>
    <strong>
     Objetivos
    </strong>
   </p>
   <ul>
    <li>
     Modelar datos con compatibilidad estructural, tuplas,
     <code>
      readonly
     </code>
     ,
     <code>
      enum
     </code>
     (pros/contras).
    </li>
   </ul>
   <h3 id="1-teoria_1">
    1) Teoría
   </h3>
   <h4 id="type-vs-interface-en-typescript-cual-y-cuando-usar">
    <code>
     type
    </code>
    vs.
    <code>
     interface
    </code>
    en TypeScript: ¿Cuál y Cuándo Usar?
   </h4>
   <p>
    Tanto
    <code>
     type
    </code>
    como
    <code>
     interface
    </code>
    son herramientas de TypeScript para definir "contratos" o "formas" que los datos deben cumplir. En muchos casos son intercambiables, pero tienen diferencias clave que los hacen más adecuados para ciertas situaciones.
   </p>
   <h3 id="semejanzas-fundamentales">
    Semejanzas Fundamentales
   </h3>
   <p>
    Antes de ver las diferencias, es importante saber que ambos pueden:
*   Describir la forma de un objeto o una función.
*   Extenderse o heredar de otros tipos (usando
    <code>
     extends
    </code>
    en
    <code>
     interface
    </code>
    y uniones/intersecciones
    <code>
     &amp;
    </code>
    en
    <code>
     type
    </code>
    ).
*   Ser implementados por una clase (
    <code>
     class MiClase implements MiInterfaz {}
    </code>
    ).
*   Usar genéricos (
    <code>
     &lt;T&gt;
    </code>
    ), propiedades opcionales (
    <code>
     ?
    </code>
    ), de solo lectura (
    <code>
     readonly
    </code>
    ) y firmas de índice (
    <code>
     [key: string]: any
    </code>
    ).
   </p>
   <h5 id="diferencias-clave">
    Diferencias Clave
   </h5>
   <p>
    Aquí es donde la elección se vuelve importante.
   </p>
   <h6 id="1-extensibilidad-interface-se-puede-fusionar-declaration-merging">
    1. 🧩 Extensibilidad:
    <code>
     interface
    </code>
    se puede fusionar (
    <em>
     Declaration Merging
    </em>
    )
   </h6>
   <p>
    Una
    <code>
     interface
    </code>
    se puede definir varias veces en el mismo ámbito. TypeScript las combina automáticamente en una sola declaración. Esto es extremadamente útil para extender tipos existentes de forma segura.
   </p>
   <p>
    <strong>
     <code>
      interface
     </code>
     (se fusiona):
    </strong>
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="c1">// Declaración inicial</span>
<span class="kd">interface</span><span class="w"> </span><span class="nx">Usuario</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// En otro archivo o más abajo, la extendemos</span>
<span class="kd">interface</span><span class="w"> </span><span class="nx">Usuario</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// TypeScript la ve como una sola interfaz</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">miUsuario</span><span class="o">:</span><span class="w"> </span><span class="kt">Usuario</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="s2">"abc-123"</span><span class="p">,</span>
<span class="w">  </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="s2">"Ana"</span><span class="p">,</span><span class="w"> </span><span class="c1">// Ambas propiedades son requeridas</span>
<span class="p">};</span>
</pre>
    </div>
   </div>
   <p>
    Esta característica hace que
    <code>
     interface
    </code>
    sea ideal para trabajar con tipos que pueden ser extendidos por terceros, como los tipos del DOM o en el desarrollo de librerías.
   </p>
   <p>
    <code>
     type
    </code>
    , en cambio, no se puede reabrir. Si intentas declarar el mismo
    <code>
     type
    </code>
    dos veces, obtendrás un error.
   </p>
   <h6 id="2-versatilidad-type-puede-ser-un-alias-para-cualquier-tipo">
    2. 🌀 Versatilidad:
    <code>
     type
    </code>
    puede ser un alias para cualquier tipo
   </h6>
   <p>
    Mientras que una
    <code>
     interface
    </code>
    solo puede describir la forma de un objeto o función, un
    <code>
     type
    </code>
    es un
    <strong>
     alias
    </strong>
    que puede representar cualquier tipo, incluyendo:
*
    <strong>
     Uniones
    </strong>
    :
    <code>
     string | number
    </code>
    *
    <strong>
     Tuplas
    </strong>
    :
    <code>
     [number, number]
    </code>
    *
    <strong>
     Tipos primitivos
    </strong>
    :
    <code>
     string
    </code>
    ,
    <code>
     boolean
    </code>
    *
    <strong>
     Tipos avanzados
    </strong>
    :
    <em>
     Mapped Types
    </em>
    y
    <em>
     Conditional Types
    </em>
    .
   </p>
   <p>
    <strong>
     <code>
      type
     </code>
     (alias versátil):
    </strong>
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="c1">// Un alias para una unión de tipos</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>

<span class="c1">// Un alias para una tupla</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Coordenada</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">];</span>

<span class="c1">// Un alias para un tipo de función</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">;</span>

<span class="c1">// Usando tipos avanzados (imposible con interface)</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">ClavesDeUsuario</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">keyof</span><span class="w"> </span><span class="nx">Usuario</span><span class="p">;</span><span class="w"> </span><span class="c1">// "id" | "nombre"</span>
</pre>
    </div>
   </div>
   <h3 id="tabla-comparativa-rapida">
    Tabla Comparativa Rápida
   </h3>
   <table>
    <thead>
     <tr>
      <th style="text-align: left;">
       Característica
      </th>
      <th style="text-align: left;">
       <code>
        interface
       </code>
      </th>
      <th style="text-align: left;">
       <code>
        type
       </code>
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td style="text-align: left;">
       <strong>
        Describe objetos/funciones
       </strong>
      </td>
      <td style="text-align: left;">
       ✅ Sí
      </td>
      <td style="text-align: left;">
       ✅ Sí
      </td>
     </tr>
     <tr>
      <td style="text-align: left;">
       <strong>
        Puede fusionarse (Merging)
       </strong>
      </td>
      <td style="text-align: left;">
       ✅ Sí
      </td>
      <td style="text-align: left;">
       ❌ No
      </td>
     </tr>
     <tr>
      <td style="text-align: left;">
       <strong>
        Alias para uniones, tuplas, primitivos
       </strong>
      </td>
      <td style="text-align: left;">
       ❌ No
      </td>
      <td style="text-align: left;">
       ✅ Sí
      </td>
     </tr>
     <tr>
      <td style="text-align: left;">
       <strong>
        Uso con Mapped/Conditional Types
       </strong>
      </td>
      <td style="text-align: left;">
       ❌ No
      </td>
      <td style="text-align: left;">
       ✅ Sí
      </td>
     </tr>
    </tbody>
   </table>
   <h3 id="recomendacion-practica-cuando-usar-cada-uno">
    Recomendación Práctica: ¿Cuándo Usar Cada Uno?
   </h3>
   <p>
    Basado en estas diferencias, aquí tienes una guía simple:
   </p>
   <p>
    ➡️
    <strong>
     Usa
     <code>
      interface
     </code>
     cuando:
    </strong>
    *   Estás definiendo un contrato para un
    <strong>
     objeto
    </strong>
    o una
    <strong>
     clase
    </strong>
    .
*   Esperas que otros puedan extender tu contrato (por ejemplo, al crear una API pública o una librería).
   </p>
   <p>
    ➡️
    <strong>
     Usa
     <code>
      type
     </code>
     cuando:
    </strong>
    *   Necesitas definir un alias para un tipo primitivo, una unión, o una tupla.
*   Necesitas usar tipos avanzados como
    <em>
     mapped types
    </em>
    o
    <em>
     conditional types
    </em>
    .
   </p>
   <p>
    <strong>
     ¿Y para el código de mi aplicación?
    </strong>
    Si no estás creando una librería, la elección entre
    <code>
     type
    </code>
    e
    <code>
     interface
    </code>
    para describir objetos es a menudo una cuestión de preferencia. Lo más importante es
    <strong>
     ser consistente
    </strong>
    dentro de tu proyecto.
   </p>
   <h4 id="13-uniones-e-intersecciones-combinando-tipos-en-typescript">
    1.3 Uniones (
    <code>
     |
    </code>
    ) e Intersecciones (
    <code>
     &amp;
    </code>
    ): Combinando Tipos en TypeScript
   </h4>
   <p>
    En
    <em>
     TypeScript
    </em>
    , las uniones y las intersecciones son dos herramientas fundamentales que te permiten crear tipos nuevos y flexibles a partir de otros ya existentes.
   </p>
   <h5 id="1-union-el-tipo-o">
    1. Unión (
    <code>
     |
    </code>
    ): El tipo "O"
   </h5>
   <p>
    Una unión crea un tipo que puede ser
    <strong>
     uno de varios tipos posibles
    </strong>
    . Piensa en el operador
    <code>
     |
    </code>
    como un "O" lógico. Un valor de este tipo debe satisfacer la forma de
    <em>
     al menos uno
    </em>
    de los tipos de la unión.
   </p>
   <p>
    <strong>
     ¿Para qué es útil?
    </strong>
    Es perfecto para modelar situaciones donde un valor puede tener múltiples formas, como los diferentes estados de una aplicación, respuestas de una API o parámetros de una función.
   </p>
   <p>
    <strong>
     Ejemplo Práctico: Manejo de Estados
    </strong>
   </p>
   <p>
    Imagina que estás cargando datos. El estado solo puede ser
    <code>
     "cargando"
    </code>
    ,
    <code>
     "exito"
    </code>
    o
    <code>
     "error"
    </code>
    . Una unión de tipos literales es la herramienta perfecta para esto.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="c1">// Define una unión de literales para representar los posibles estados</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">EstadoDeCarga</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"cargando"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">"exito"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">"error"</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">mostrarMensaje</span><span class="p">(</span><span class="nx">estado</span><span class="o">:</span><span class="w"> </span><span class="kt">EstadoDeCarga</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">estado</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"cargando"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Loading data..."</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">estado</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"exito"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"¡Datos cargados correctamente!"</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Gracias a la unión, TypeScript sabe que la única opción restante es "error"</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s2">"Hubo un fallo en la carga."</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">mostrarMensaje</span><span class="p">(</span><span class="s2">"exito"</span><span class="p">);</span><span class="w"> </span><span class="c1">// Muestra: "¡Datos cargados correctamente!"</span>
<span class="c1">// mostrarMensaje("pendiente"); // ❌ Error: "pendiente" no es un valor válido para el tipo EstadoDeCarga.</span>
</pre>
    </div>
   </div>
   <h5 id="2-interseccion-el-tipo-y">
    2. Intersección (
    <code>
     &amp;
    </code>
    ): El tipo "Y"
   </h5>
   <p>
    Una intersección crea un nuevo tipo que
    <strong>
     combina todas las propiedades de los tipos existentes
    </strong>
    . Piensa en el operador
    <code>
     &amp;
    </code>
    como un "Y" lógico. Un valor de este tipo debe satisfacer las formas de
    <em>
     todos
    </em>
    los tipos de la intersección simultáneamente.
   </p>
   <p>
    <strong>
     ¿Para qué es útil?
    </strong>
    Es ideal para componer tipos complejos a partir de piezas más pequeñas y reutilizables, como si estuvieras mezclando diferentes características.
   </p>
   <p>
    <strong>
     Ejemplo Práctico: Composición de Objetos
    </strong>
   </p>
   <p>
    Supongamos que en tu base de datos, cualquier registro tiene un
    <code>
     id
    </code>
    , y algunos también tienen marcas de tiempo (
    <code>
     timestamps
    </code>
    ). Puedes modelar esto de forma muy limpia.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="kr">type</span><span class="w"> </span><span class="nx">ConIdentificador</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">type</span><span class="w"> </span><span class="nx">ConTimestamps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">createdAt</span><span class="o">:</span><span class="w"> </span><span class="kt">Date</span><span class="p">;</span>
<span class="w">  </span><span class="nx">updatedAt</span><span class="o">:</span><span class="w"> </span><span class="kt">Date</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Un registro de la base de datos debe tener AMBAS cosas: un ID Y timestamps.</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">RegistroDB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ConIdentificador</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nx">ConTimestamps</span><span class="p">;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">usuario</span><span class="o">:</span><span class="w"> </span><span class="kt">RegistroDB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="s2">"user-123"</span><span class="p">,</span>
<span class="w">  </span><span class="nx">createdAt</span><span class="o">:</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="nb">Date</span><span class="p">(),</span>
<span class="w">  </span><span class="nx">updatedAt</span><span class="o">:</span><span class="w"> </span><span class="kt">new</span><span class="w"> </span><span class="nb">Date</span><span class="p">(),</span><span class="w"> </span><span class="c1">// Todas las propiedades son obligatorias.</span>
<span class="p">};</span>
</pre>
    </div>
   </div>
   <h5 id="resumen-visual-vs">
    Resumen Visual:
    <code>
     |
    </code>
    vs.
    <code>
     &amp;
    </code>
   </h5>
   <table>
    <thead>
     <tr>
      <th style="text-align: left;">
       Característica
      </th>
      <th style="text-align: left;">
       Unión (
       <code>
        A \| B
       </code>
       )
      </th>
      <th style="text-align: left;">
       Intersección (
       <code>
        A &amp; B
       </code>
       )
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td style="text-align: left;">
       <strong>
        Lógica
       </strong>
      </td>
      <td style="text-align: left;">
       "O" (es A o es B)
      </td>
      <td style="text-align: left;">
       "Y" (es A y también es B)
      </td>
     </tr>
     <tr>
      <td style="text-align: left;">
       <strong>
        Propiedades (Objetos)
       </strong>
      </td>
      <td style="text-align: left;">
       Debe tener las propiedades comunes a A y B.
      </td>
      <td style="text-align: left;">
       Debe tener
       <strong>
        todas
       </strong>
       las propiedades de A y de B.
      </td>
     </tr>
     <tr>
      <td style="text-align: left;">
       <strong>
        Caso de uso principal
       </strong>
      </td>
      <td style="text-align: left;">
       Modelar valores que pueden ser de diferentes tipos (ej:
       <code>
        string | number
       </code>
       , estados).
      </td>
      <td style="text-align: left;">
       Componer y mezclar tipos de objetos para crear formas más complejas.
      </td>
     </tr>
    </tbody>
   </table>
   <h4 id="13-tipos-literales-y-uniones-discriminadas-discriminated-unions">
    1.3 Tipos Literales y Uniones Discriminadas (
    <em>
     Discriminated Unions
    </em>
    )
   </h4>
   <p>
    Estos dos conceptos, al combinarse, crean uno de los patrones más potentes y seguros en
    <em>
     Typescript
    </em>
    para manejar datos que pueden tener diferentes "formas" o "estados".
   </p>
   <ul>
    <li>
     <p>
      <strong>
       Tipos Literales
      </strong>
      : Un tipo literal es un tipo tan específico que solo permite un valor exacto. En lugar de permitir cualquier
      <code>
       string
      </code>
      , puedes especificar que una variable
      <em>
       solo
      </em>
      puede ser el string
      <code>
       "ok"
      </code>
      ,
      <code>
       "error"
      </code>
      , el número
      <code>
       1
      </code>
      o el booleano
      <code>
       true
      </code>
      . Esto aumenta enormemente la predictibilidad de tu código.
     </p>
    </li>
    <li>
     <p>
      <strong>
       Uniones Discriminadas
      </strong>
      : Son un patrón avanzado que combina uniones (
      <code>
       |
      </code>
      ) y tipos literales para crear tipos "inteligentes". La idea es usar una propiedad común con un tipo literal (el
      <strong>
       discriminante
      </strong>
      , usualmente llamado
      <code>
       kind
      </code>
      ,
      <code>
       type
      </code>
      o
      <code>
       status
      </code>
      ) para que
      <em>
       Typescript
      </em>
      pueda deducir ("estrechar" o
      <em>
       narrowing
      </em>
      ) de forma exacta qué forma tiene el objeto dentro de un bloque de código.
     </p>
    </li>
   </ul>
   <p>
    <strong>
     La Receta para una Unión Discriminada:
    </strong>
    1.  Define varios tipos de objeto.
2.  Añade a cada uno una propiedad común (ej.
    <code>
     kind
    </code>
    ) con un valor literal
    <strong>
     único
    </strong>
    .
3.  Crea un tipo unión que agrupe a todos los anteriores.
   </p>
   <p>
    <strong>
     Ejemplo en acción:
    </strong>
   </p>
   <p>
    Imaginemos que queremos modelar el estado de un producto en un inventario.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="c1">// Cada "estado" tiene una forma diferente, pero comparte la propiedad "kind".</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Disponible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s2">"disponible"</span><span class="p">;</span><span class="w"> </span><span class="c1">// El discriminante</span>
<span class="w">  </span><span class="nx">stock</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">type</span><span class="w"> </span><span class="nx">Discontinuado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s2">"discontinuado"</span><span class="p">;</span><span class="w"> </span><span class="c1">// El discriminante</span>
<span class="w">  </span><span class="nx">razon</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 3. La unión que agrupa todos los posibles estados.</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">EstadoProducto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Disponible</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Discontinuado</span><span class="p">;</span>
</pre>
    </div>
   </div>
   <p>
    <strong>
     La magia del
     <em>
      estrechamiento exhaustivo
     </em>
     (
     <em>
      Exhaustive Narrowing
     </em>
     )
    </strong>
   </p>
   <p>
    Ahora, al usar una estructura de control como
    <code>
     switch
    </code>
    ,
    <em>
     Typescript
    </em>
    puede identificar qué propiedades están disponibles en cada caso, eliminando por completo una categoría de errores.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="kd">function</span><span class="w"> </span><span class="nx">obtenerDetalleProducto</span><span class="p">(</span><span class="nx">producto</span><span class="o">:</span><span class="w"> </span><span class="kt">EstadoProducto</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="nx">producto</span><span class="p">.</span><span class="nx">kind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s2">"disponible"</span><span class="o">:</span>
<span class="w">      </span><span class="c1">// Dentro de este bloque, Typescript SABE que 'producto' es de tipo 'Disponible'.</span>
<span class="w">      </span><span class="c1">// Por eso, nos da autocompletado para `producto.stock`.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="sb">`Hay </span><span class="si">${</span><span class="nx">producto</span><span class="p">.</span><span class="nx">stock</span><span class="si">}</span><span class="sb"> unidades en el inventario.`</span><span class="p">;</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s2">"discontinuado"</span><span class="o">:</span>
<span class="w">      </span><span class="c1">// Aquí, Typescript SABE que 'producto' es de tipo 'Discontinuado'.</span>
<span class="w">      </span><span class="c1">// Acceder a `producto.stock` daría un error.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="sb">`Producto discontinuado por la siguiente razón: </span><span class="si">${</span><span class="nx">producto</span><span class="p">.</span><span class="nx">razon</span><span class="si">}</span><span class="sb">.`</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <p>
    Este patrón es extremadamente robusto. Si en el futuro añadieras un nuevo estado (ej.
    <code>
     type Proximamente = { kind: "proximamente"; fechaLanzamiento: Date }
    </code>
    ) a la unión
    <code>
     EstadoProducto
    </code>
    ,
    <em>
     Typescript
    </em>
    te daría un error en la función
    <code>
     obtenerDetalleProducto
    </code>
    , forzándote a manejar ese nuevo caso. Esto garantiza que nunca olvides actualizar tu lógica.
   </p>
   <h4 id="14-tuplas-readonly-y-la-alternativa-a-los-enum">
    1.4 Tuplas,
    <code>
     readonly
    </code>
    y la alternativa a los
    <code>
     enum
    </code>
   </h4>
   <p>
    Estos conceptos de
    <em>
     Typescript
    </em>
    te permiten crear estructuras de datos más estrictas, predecibles y seguras.
   </p>
   <ul>
    <li>
     <p>
      <strong>
       Tuplas: Arrays con Estructura Fija
      </strong>
     </p>
     <p>
      Una tupla es como un array con reglas muy estrictas: tiene una
      <strong>
       longitud fija
      </strong>
      y un
      <strong>
       tipo de dato específico para cada posición
      </strong>
      . Esto es ideal para representar datos que tienen una estructura interna, como un par de coordenadas o, en este caso, una cantidad monetaria.
     </p>
     <p>
      <div class="highlight language-ts">
       <pre><span></span><span class="w">    </span><span class="c1">// Una tupla que SIEMPRE tendrá dos elementos: un número y luego un string.</span>
<span class="w">    </span><span class="kr">type</span><span class="w"> </span><span class="nx">ParCoordenada</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">];</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">miPar</span><span class="o">:</span><span class="w"> </span><span class="kt">ParCoordenada</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">10</span><span class="p">,</span><span class="w"> </span><span class="s2">"Norte"</span><span class="p">];</span><span class="w"> </span><span class="c1">// ✅ Válido</span>
<span class="w">    </span><span class="c1">// const otroPar: ParCoordenada = ["Sur", 20]; // ❌ Error de tipo</span>
<span class="w">    </span><span class="c1">// const parIncompleto: ParCoordenada = [10]; // ❌ Error de longitud</span>
<span class="w">    </span>
</pre>
      </div>
     </p>
    </li>
    <li>
     <p>
      <strong>
       <code>
        readonly
       </code>
       : Garantizando la Inmutabilidad
      </strong>
     </p>
     <p>
      El modificador
      <code>
       readonly
      </code>
      se puede aplicar a propiedades de objetos, arrays o tuplas para evitar que sean modificados después de su creación. Esto ayuda a prevenir errores causados por mutaciones accidentales.
     </p>
     <p>
      <div class="highlight language-ts">
       <pre><span></span><span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">numeros</span><span class="o">:</span><span class="w"> </span><span class="kt">readonly</span><span class="w"> </span><span class="kt">number</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// numeros.push(4); // ❌ Error: La propiedad 'push' no existe en 'readonly number[]'.</span>
<span class="w">    </span>
</pre>
      </div>
     </p>
    </li>
    <li>
     <p>
      <strong>
       <code>
        enum
       </code>
       vs. Unión de Literales: La Alternativa Moderna
      </strong>
     </p>
     <p>
      Tradicionalmente, para representar un conjunto de constantes con nombre, se usaban los
      <code>
       enum
      </code>
      . Sin embargo, los
      <code>
       enum
      </code>
      generan un objeto real en el JavaScript compilado, lo que puede tener implicaciones en el tamaño del paquete final y su optimización (
      <em>
       tree-shaking
      </em>
      ).
     </p>
     <p>
      Hoy en día, la alternativa preferida en la mayoría de los casos es una
      <strong>
       unión de tipos literales
      </strong>
      . Es más ligera (desaparece en la compilación), más simple y a menudo más segura.
     </p>
     <p>
      <div class="highlight language-ts">
       <div class="collapsible-container" data-max-lines="6">
        <pre><span></span><span class="w">    </span><span class="c1">// Alternativa con enum (genera código JS)</span>
<span class="w">    </span><span class="kd">enum</span><span class="w"> </span><span class="nx">MonedaEnum</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">ARS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"ARS"</span><span class="p">,</span>
<span class="w">      </span><span class="nx">USD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"USD"</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Alternativa moderna con unión de literales (solo existe en tiempo de compilación)</span>
<span class="w">    </span><span class="kr">type</span><span class="w"> </span><span class="nx">MonedaLiteral</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"ARS"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">"USD"</span><span class="p">;</span>
<span class="w">    </span>
</pre>
       </div>
      </div>
     </p>
    </li>
   </ul>
   <p>
    <strong>
     Ejemplo Combinado: Un Tipo de Dato Robusto
    </strong>
   </p>
   <p>
    Podemos combinar estos tres conceptos para crear un tipo
    <code>
     Dinero
    </code>
    que sea seguro, inmutable y descriptivo.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="c1">// Esta tupla:</span>
<span class="c1">// 1. Es `readonly`: no se puede modificar una vez creada.</span>
<span class="c1">// 2. Tiene una estructura fija: un número seguido de un string.</span>
<span class="c1">// 3. Usa etiquetas (`monto`, `moneda`) para mejorar la legibilidad.</span>
<span class="c1">// 4. Usa una unión de literales para restringir la moneda a valores válidos.</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Dinero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">readonly</span><span class="w"> </span><span class="p">[</span><span class="nx">monto</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="nx">moneda</span><span class="o">:</span><span class="w"> </span><span class="s2">"ARS"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">"USD"</span><span class="p">];</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">precio</span><span class="o">:</span><span class="w"> </span><span class="kt">Dinero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">2500</span><span class="p">,</span><span class="w"> </span><span class="s2">"ARS"</span><span class="p">];</span>

<span class="c1">// precio[0] = 3000; // ❌ Error: La tupla es de solo lectura.</span>
<span class="c1">// precio.push("EUR"); // ❌ Error: La tupla es de solo lectura y tiene longitud fija.</span>
<span class="c1">// const precioInvalido: Dinero = [100, "EUR"]; // ❌ Error: "EUR" no es un tipo de moneda válido.</span>
</pre>
    </div>
   </div>
   <h4 id="15-narrowing-como-typescript-entiende-tu-codigo">
    1.5
    <em>
     Narrowing
    </em>
    : Cómo
    <em>
     Typescript
    </em>
    Entiende tu Código
   </h4>
   <p>
    <em>
     Narrowing
    </em>
    (o "estrechamiento") es el proceso que realiza
    <em>
     Typescript
    </em>
    para deducir un tipo más específico para una variable dentro de un bloque de código. Después de realizar una comprobación,
    <em>
     Typescript
    </em>
    es lo suficientemente inteligente como para saber que la variable tiene una forma más concreta, desbloqueando así el autocompletado y la seguridad de tipos.
   </p>
   <p>
    Estas son las herramientas principales para lograrlo:
   </p>
   <p>
    <strong>
     1.
     <code>
      typeof
     </code>
     : Para Tipos Primitivos
    </strong>
   </p>
   <p>
    Es la forma más común de diferenciar entre tipos primitivos como
    <code>
     string
    </code>
    ,
    <code>
     number
    </code>
    ,
    <code>
     boolean
    </code>
    , etc.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="kd">function</span><span class="w"> </span><span class="nx">procesar</span><span class="p">(</span><span class="nx">valor</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="ow">typeof</span><span class="w"> </span><span class="nx">valor</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"string"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Dentro de este bloque, TypeScript sabe que 'valor' es SÓLO un string.</span>
<span class="w">    </span><span class="c1">// Por lo tanto, `valor.toUpperCase()` es una operación segura.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">valor</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Fuera del if, TypeScript deduce que 'valor' debe ser un number.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">valor</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mf">2</span><span class="p">);</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <p>
    <strong>
     2. El operador
     <code>
      in
     </code>
     : Para Verificar Propiedades en Objetos
    </strong>
   </p>
   <p>
    Se utiliza para determinar si un objeto tiene una propiedad con un nombre específico. Es muy útil para diferenciar entre las distintas formas que puede tener un objeto en una unión.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="kr">type</span><span class="w"> </span><span class="nx">Disponible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">stock</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">};</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Discontinuado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">razon</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">};</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">EstadoProducto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Disponible</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Discontinuado</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">obtenerStock</span><span class="p">(</span><span class="nx">producto</span><span class="o">:</span><span class="w"> </span><span class="kt">EstadoProducto</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="s2">"stock"</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">producto</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Si la propiedad "stock" existe, TypeScript sabe que 'producto' es de tipo 'Disponible'.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">producto</span><span class="p">.</span><span class="nx">stock</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Si no, debe ser de tipo 'Discontinuado'.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <p>
    <strong>
     3.
     <code>
      instanceof
     </code>
     : Para Instancias de Clases
    </strong>
   </p>
   <p>
    Funciona de manera similar a
    <code>
     typeof
    </code>
    , pero en el mundo de las clases. Verifica si un objeto es una instancia de una clase específica (o de una que herede de ella).
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nx">Caja</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">constructor</span><span class="p">(</span><span class="k">public</span><span class="w"> </span><span class="nx">valor</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">desempaquetar</span><span class="p">(</span><span class="nx">item</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Caja</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">item</span><span class="w"> </span><span class="ow">instanceof</span><span class="w"> </span><span class="nx">Caja</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// En este bloque, TypeScript sabe que 'item' es una instancia de 'Caja'.</span>
<span class="w">    </span><span class="c1">// Por lo tanto, `item.valor` es un acceso seguro.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">item</span><span class="p">.</span><span class="nx">valor</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// Si no es una instancia de Caja, debe ser un número.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">item</span><span class="p">;</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <p>
    <strong>
     4. Predicados de Tipo (
     <code>
      is
     </code>
     ): Creando tus Propias Validaciones
    </strong>
   </p>
   <p>
    A veces, la lógica para validar un tipo es más compleja y necesitas encapsularla en una función. Un predicado de tipo es una firma de retorno especial (
    <code>
     parametro is Tipo
    </code>
    ) que le dice a
    <em>
     Typescript
    </em>
    : "Si esta función devuelve
    <code>
     true
    </code>
    , puedes confiar en que el parámetro que le pasé es de este tipo más específico".
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="c1">// Definimos de nuevo los tipos de producto, pero esta vez con un discriminante.</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Disponible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s2">"disponible"</span><span class="p">;</span><span class="w"> </span><span class="nx">stock</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">};</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Discontinuado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s2">"discontinuado"</span><span class="p">;</span><span class="w"> </span><span class="nx">razon</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">};</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">EstadoProducto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Disponible</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Discontinuado</span><span class="p">;</span>

<span class="c1">// La función predicado: su retorno le "enseña" a TypeScript.</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">esDisponible</span><span class="p">(</span><span class="nx">producto</span><span class="o">:</span><span class="w"> </span><span class="kt">EstadoProducto</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">producto</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">Disponible</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">producto</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"disponible"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">manejarProducto</span><span class="p">(</span><span class="nx">producto</span><span class="o">:</span><span class="w"> </span><span class="kt">EstadoProducto</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">esDisponible</span><span class="p">(</span><span class="nx">producto</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Gracias al predicado, TypeScript sabe que 'producto' es 'Disponible' aquí.</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Tenemos </span><span class="si">${</span><span class="nx">producto</span><span class="p">.</span><span class="nx">stock</span><span class="si">}</span><span class="sb"> en inventario.`</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <hr/>
   <h3 id="2-practica">
    2) Práctica
   </h3>
   <p>
    Crea los archivos de esta semana dentro de
    <code>
     src/
    </code>
    y ejecuta
    <code>
     npm run typecheck
    </code>
    frecuentemente.
   </p>
   <h4 id="21-modelado-basico-src02-modeladots">
    2.1 Modelado básico (
    <code>
     src/02-modelado.ts
    </code>
    )
   </h4>
   <p>
    <strong>
     Objetivo
    </strong>
    : modelar un catálogo con tipos sólidos y hacer
    <em>
     narrowing
    </em>
    seguro.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="c1">// Identidades y literales</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">SKU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="kt">string</span><span class="si">}</span><span class="sb">-</span><span class="si">${</span><span class="kt">number</span><span class="si">}</span><span class="sb">`</span>

<span class="kr">type</span><span class="w"> </span><span class="nx">Moneda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"ARS"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">"USD"</span>
<span class="k">export</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="nx">Dinero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">readonly</span><span class="w"> </span><span class="p">[</span><span class="nx">monto</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="nx">moneda</span><span class="o">:</span><span class="w"> </span><span class="kt">Moneda</span><span class="p">]</span>

<span class="c1">// Formas base</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">BaseProducto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">sku</span><span class="o">:</span><span class="w"> </span><span class="kt">SKU</span><span class="p">;</span><span class="w"> </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w"> </span><span class="nx">precio</span><span class="o">:</span><span class="w"> </span><span class="kt">Dinero</span><span class="w"> </span><span class="p">}</span>

<span class="kr">type</span><span class="w"> </span><span class="nx">Disponible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s2">"disp"</span><span class="p">;</span><span class="w"> </span><span class="nx">stock</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">}</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Discontinuado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s2">"disc"</span><span class="p">;</span><span class="w"> </span><span class="nx">razon</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">}</span>
<span class="k">export</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="nx">EstadoProducto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Disponible</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Discontinuado</span>

<span class="k">export</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="nx">Producto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">BaseProducto</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">estado</span><span class="o">:</span><span class="w"> </span><span class="kt">EstadoProducto</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Guards y utilidades</span>
<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">esDisponible</span><span class="p">(</span><span class="nx">e</span><span class="o">:</span><span class="w"> </span><span class="kt">EstadoProducto</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">Disponible</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">e</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"disp"</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">precioEnARS</span><span class="p">([</span><span class="nx">m</span><span class="p">,</span><span class="w"> </span><span class="nx">mon</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="nx">Dinero</span><span class="p">,</span><span class="w"> </span><span class="nx">tc</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">mon</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"USD"</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">tc</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">m</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">puedeVender</span><span class="p">(</span><span class="nx">p</span><span class="o">:</span><span class="w"> </span><span class="kt">Producto</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">esDisponible</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">estado</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">p</span><span class="p">.</span><span class="nx">estado</span><span class="p">.</span><span class="nx">stock</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// Ejemplos</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">p1</span><span class="o">:</span><span class="w"> </span><span class="kt">Producto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">sku</span><span class="o">:</span><span class="w"> </span><span class="s2">"abc-101"</span><span class="p">,</span>
<span class="w">  </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="s2">"Teclado"</span><span class="p">,</span>
<span class="w">  </span><span class="nx">precio</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">100</span><span class="p">,</span><span class="w"> </span><span class="s2">"USD"</span><span class="p">],</span>
<span class="w">  </span><span class="nx">estado</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s2">"disp"</span><span class="p">,</span><span class="w"> </span><span class="nx">stock</span><span class="o">:</span><span class="w"> </span><span class="kt">5</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">p2</span><span class="o">:</span><span class="w"> </span><span class="kt">Producto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">sku</span><span class="o">:</span><span class="w"> </span><span class="s2">"abc-102"</span><span class="p">,</span>
<span class="w">  </span><span class="nx">nombre</span><span class="o">:</span><span class="w"> </span><span class="s2">"Mouse"</span><span class="p">,</span>
<span class="w">  </span><span class="nx">precio</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="mf">15000</span><span class="p">,</span><span class="w"> </span><span class="s2">"ARS"</span><span class="p">],</span>
<span class="w">  </span><span class="nx">estado</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s2">"disc"</span><span class="p">,</span><span class="w"> </span><span class="nx">razon</span><span class="o">:</span><span class="w"> </span><span class="s2">"Reemplazado por nuevo modelo"</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"p1 en ARS:"</span><span class="p">,</span><span class="w"> </span><span class="nx">precioEnARS</span><span class="p">(</span><span class="nx">p1</span><span class="p">.</span><span class="nx">precio</span><span class="p">,</span><span class="w"> </span><span class="mf">1000</span><span class="p">))</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"¿p1 vendible?"</span><span class="p">,</span><span class="w"> </span><span class="nx">puedeVender</span><span class="p">(</span><span class="nx">p1</span><span class="p">))</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"¿p2 vendible?"</span><span class="p">,</span><span class="w"> </span><span class="nx">puedeVender</span><span class="p">(</span><span class="nx">p2</span><span class="p">))</span>
</pre>
    </div>
   </div>
   <p>
    <strong>
     Explicación
    </strong>
    :
   </p>
   <p>
    <strong>
     Identidades y Literales
    </strong>
   </p>
   <p>
    Aquí se definen tipos básicos que actúan como "identidades" o valores específicos.
   </p>
   <ul>
    <li>
     <p>
      <strong>
       <code>
        type SKU =
       </code>
       ${string}-${number}``
      </strong>
     </p>
     <ul>
      <li>
       <code>
        SKU
       </code>
       significa "Stock Keeping Unit" (unidad de mantenimiento de existencias).
      </li>
      <li>
       Este es un
       <strong>
        tipo de cadena literal de plantilla
       </strong>
       . Significa que un valor de
       <code>
        SKU
       </code>
       debe ser una cadena que comienza con cualquier cadena (
       <code>
        string
       </code>
       ), seguida de un guion (
       <code>
        -
       </code>
       ), y luego por cualquier número (
       <code>
        number
       </code>
       ).
      </li>
     </ul>
    </li>
    <li>
     <p>
      <strong>
       <code>
        type Moneda = "ARS" | "USD"
       </code>
      </strong>
     </p>
     <ul>
      <li>
       <code>
        Moneda
       </code>
       es un
       <strong>
        tipo de unión literal de cadena
       </strong>
       . Significa que una variable de tipo
       <code>
        Moneda
       </code>
       solo puede tener el valor
       <code>
        "ARS"
       </code>
       (pesos argentinos) o
       <code>
        "USD"
       </code>
       (dólares estadounidenses). No se permiten otros valores.
      </li>
     </ul>
    </li>
    <li>
     <p>
      <strong>
       <code>
        export type Dinero = readonly [monto: number, moneda: Moneda]
       </code>
      </strong>
     </p>
     <ul>
      <li>
       <code>
        Dinero
       </code>
       es una
       <strong>
        tupla
        <code>
         readonly
        </code>
       </strong>
       .
   Una tupla es un array con un número fijo de elementos y tipos conocidos para cada elemento.
      </li>
      <li>
       <code>
        readonly
       </code>
       significa que una vez creada, no se pueden cambiar los elementos de la tupla.
 Tiene dos elementos:
       <ul>
        <li>
         <code>
          monto
         </code>
         : Un
         <code>
          number
         </code>
         que representa la cantidad de dinero.
        </li>
        <li>
         <code>
          moneda
         </code>
         : Una
         <code>
          Moneda
         </code>
         (ya sea
         <code>
          "ARS"
         </code>
         o
         <code>
          "USD"
         </code>
         ).
   Los nombres
         <code>
          monto
         </code>
         y
         <code>
          moneda
         </code>
         son etiquetas opcionales para mejorar la legibilidad, pero no cambian el tipo subyacente.
        </li>
       </ul>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <strong>
     Formas Base
    </strong>
    Estos tipos definen la estructura principal de un producto.
   </p>
   <ul>
    <li>
     <strong>
      <code>
       type BaseProducto = { sku: SKU; nombre: string; precio: Dinero }
      </code>
     </strong>
     Este es un
     <strong>
      tipo de objeto
     </strong>
     que define las propiedades comunes a cualquier producto.
     <ul>
      <li>
       <code>
        sku
       </code>
       : De tipo
       <code>
        SKU
       </code>
       (nuestro formato
       <code>
        string-number
       </code>
       ).
      </li>
      <li>
       <code>
        nombre
       </code>
       : Una
       <code>
        string
       </code>
       para el nombre del producto.
      </li>
      <li>
       <code>
        precio
       </code>
       : De tipo
       <code>
        Dinero
       </code>
       (nuestra tupla
       <code>
        [monto, moneda]
       </code>
       ).
      </li>
     </ul>
    </li>
    <li>
     <strong>
      <code>
       type Disponible = { kind: "disp"; stock: number }
      </code>
     </strong>
     <ul>
      <li>
       Este es un tipo de objeto que representa el estado de un producto
       <strong>
        disponible
       </strong>
       .
      </li>
      <li>
       <code>
        kind: "disp"
       </code>
       : Una
       <strong>
        propiedad literal
       </strong>
       que actúa como un "discriminador". Esto es clave para distinguir entre los diferentes estados de un producto. Si
       <code>
        kind
       </code>
       es
       <code>
        "disp"
       </code>
       , sabemos que es un producto disponible.
      </li>
      <li>
       <code>
        stock
       </code>
       : Un
       <code>
        number
       </code>
       que indica la cantidad de unidades en stock.
      </li>
     </ul>
    </li>
    <li>
     <strong>
      <code>
       type Discontinuado = { kind: "disc"; razon: string }
      </code>
     </strong>
     <ul>
      <li>
       Similar a
       <code>
        Disponible
       </code>
       , pero para productos
       <strong>
        discontinuados
       </strong>
       .
      </li>
      <li>
       <code>
        kind: "disc"
       </code>
       : El discriminador para este estado.
      </li>
      <li>
       <code>
        razon
       </code>
       : Una
       <code>
        string
       </code>
       que explica por qué el producto fue discontinuado.
      </li>
     </ul>
    </li>
    <li>
     <strong>
      <code>
       export type EstadoProducto = Disponible | Discontinuado
      </code>
     </strong>
     <ul>
      <li>
       Este es un
       <strong>
        tipo de unión
       </strong>
       . Un
       <code>
        EstadoProducto
       </code>
       puede ser
       <em>
        o
       </em>
       <code>
        Disponible
       </code>
       <em>
        o
       </em>
       <code>
        Discontinuado
       </code>
       .
      </li>
      <li>
       La propiedad
       <code>
        kind
       </code>
       (
       <code>
        "disp"
       </code>
       o
       <code>
        "disc"
       </code>
       ) permite a TypeScript (y a nosotros) saber qué tipo específico de
       <code>
        EstadoProducto
       </code>
       estamos tratando en un momento dado, lo que habilita la
       <strong>
        reducción de tipos (type narrowing)
       </strong>
       .
      </li>
     </ul>
    </li>
    <li>
     <strong>
      <code>
       export type Producto = BaseProducto &amp; { estado: EstadoProducto }
      </code>
     </strong>
     <ul>
      <li>
       Este es un
       <strong>
        tipo de intersección
       </strong>
       . Combina las propiedades de
       <code>
        BaseProducto
       </code>
       con una nueva propiedad
       <code>
        estado
       </code>
       .
      </li>
      <li>
       Un
       <code>
        Producto
       </code>
       tiene
       <code>
        sku
       </code>
       ,
       <code>
        nombre
       </code>
       ,
       <code>
        precio
       </code>
       (de
       <code>
        BaseProducto
       </code>
       ) y
       <code>
        estado
       </code>
       (que puede ser
       <code>
        Disponible
       </code>
       o
       <code>
        Discontinuado
       </code>
       ).
       <strong>
        Guards y Utilidades
       </strong>
       Estas funciones ayudan a trabajar con los tipos definidos.
      </li>
     </ul>
    </li>
    <li>
     <strong>
      <code>
       export function esDisponible(e: EstadoProducto): e is Disponible { return e.kind === "disp" }
      </code>
     </strong>
     <ul>
      <li>
       Esta es una
       <strong>
        función guard de tipo (type guard)
       </strong>
       .
      </li>
      <li>
       Toma un
       <code>
        EstadoProducto
       </code>
       (
       <code>
        e
       </code>
       ).
      </li>
      <li>
       La parte
       <code>
        e is Disponible
       </code>
       es la clave: le dice a TypeScript que si esta función devuelve
       <code>
        true
       </code>
       , entonces
       <code>
        e
       </code>
       no es solo un
       <code>
        EstadoProducto
       </code>
       genérico, ¡sino que se ha reducido su tipo a
       <code>
        Disponible
       </code>
       !
      </li>
      <li>
       Internamente, verifica el discriminador
       <code>
        e.kind === "disp"
       </code>
       .
      </li>
     </ul>
    </li>
    <li>
     <strong>
      <code>
       export function precioEnARS([m, mon]: Dinero, tc: number): number { return mon === "USD" ? Math.round(m * tc) : m }
      </code>
     </strong>
     <ul>
      <li>
       Esta función calcula el precio de un
       <code>
        Dinero
       </code>
       en Pesos Argentinos (ARS).
      </li>
      <li>
       <code>
        [m, mon]: Dinero
       </code>
       : Utiliza la
       <strong>
        desestructuración de tuplas
       </strong>
       directamente en los parámetros para extraer
       <code>
        m
       </code>
       (monto) y
       <code>
        mon
       </code>
       (moneda) de la tupla
       <code>
        Dinero
       </code>
       .
      </li>
      <li>
       <code>
        tc: number
       </code>
       : Es el tipo de cambio (tasa de conversión).
      </li>
      <li>
       Si la moneda es
       <code>
        "USD"
       </code>
       , convierte el monto multiplicándolo por el tipo de cambio y lo redondea. Si es
       <code>
        "ARS"
       </code>
       , devuelve el monto directamente.
      </li>
     </ul>
    </li>
    <li>
     <strong>
      <code>
       export function puedeVender(p: Producto): boolean { if (esDisponible(p.estado)) return p.estado.stock  0 return false }
      </code>
     </strong>
     <ul>
      <li>
       Esta función determina si un
       <code>
        Producto
       </code>
       se puede vender.
      </li>
      <li>
       <code>
        if (esDisponible(p.estado))
       </code>
       : Aquí es donde entra en juego la función guard
       <code>
        esDisponible
       </code>
       . Dentro de este bloque
       <code>
        if
       </code>
       , TypeScript sabe que
       <code>
        p.estado
       </code>
       es de tipo
       <code>
        Disponible
       </code>
       , por lo que podemos acceder a
       <code>
        p.estado.stock
       </code>
       sin errores.
      </li>
      <li>
       Si el producto está disponible y tiene stock mayor que 0, se puede vender. De lo contrario, no.
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <strong>
     Ejemplos
    </strong>
   </p>
   <p>
    Finalmente, se muestran ejemplos de cómo usar los tipos y funciones.
   </p>
   <ul>
    <li>
     <strong>
      <code>
       const p1: Producto = { ... }
      </code>
     </strong>
     <ul>
      <li>
       Se crea un producto
       <code>
        p1
       </code>
       con un
       <code>
        sku
       </code>
       válido, nombre, precio en USD, y un estado
       <code>
        Disponible
       </code>
       con 5 unidades de stock.
      </li>
     </ul>
    </li>
    <li>
     <strong>
      <code>
       const p2: Producto = { ... }
      </code>
     </strong>
     <ul>
      <li>
       Se crea un producto
       <code>
        p2
       </code>
       con un
       <code>
        sku
       </code>
       válido, nombre, precio en ARS, y un estado
       <code>
        Discontinuado
       </code>
       con una razón.
      </li>
     </ul>
    </li>
    <li>
     <strong>
      <code>
       console.log("p1 en ARS:", precioEnARS(p1.precio, 1000))
      </code>
     </strong>
     <ul>
      <li>
       Llama a
       <code>
        precioEnARS
       </code>
       para
       <code>
        p1
       </code>
       .
       <code>
        p1.precio
       </code>
       es
       <code>
        [100, "USD"]
       </code>
       . Con un tipo de cambio de 1000, esto debería resultar en 100000.
      </li>
     </ul>
    </li>
    <li>
     <strong>
      <code>
       console.log("¿p1 vendible?", puedeVender(p1))
      </code>
     </strong>
     <ul>
      <li>
       Llama a
       <code>
        puedeVender
       </code>
       para
       <code>
        p1
       </code>
       . Dado que
       <code>
        p1
       </code>
       está disponible y tiene
       <code>
        stock: 5
       </code>
       , debería devolver
       <code>
        true
       </code>
       .
      </li>
     </ul>
    </li>
    <li>
     <strong>
      <code>
       console.log("¿p2 vendible?", puedeVender(p2))
      </code>
     </strong>
     <ul>
      <li>
       Llama a
       <code>
        puedeVender
       </code>
       para
       <code>
        p2
       </code>
       . Dado que
       <code>
        p2
       </code>
       está discontinuado (
       <code>
        kind: "disc"
       </code>
       ), la función
       <code>
        esDisponible
       </code>
       devolverá
       <code>
        false
       </code>
       , y por lo tanto
       <code>
        puedeVender
       </code>
       devolverá
       <code>
        false
       </code>
       .
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <strong>
     Resumen de Conceptos Clave Utilizados
    </strong>
    :
   </p>
   <ul>
    <li>
     <strong>
      Tipos Primitivos:
     </strong>
     <code>
      string
     </code>
     ,
     <code>
      number
     </code>
     ,
     <code>
      boolean
     </code>
     .
    </li>
    <li>
     <strong>
      Literales de Tipo:
     </strong>
     <code>
      "ARS"
     </code>
     ,
     <code>
      "USD"
     </code>
     ,
     <code>
      "disp"
     </code>
     ,
     <code>
      "disc"
     </code>
     .
    </li>
    <li>
     <strong>
      Uniones (
      <code>
       |
      </code>
      ):
     </strong>
     Para combinar varios tipos (ej.
     <code>
      Moneda
     </code>
     ,
     <code>
      EstadoProducto
     </code>
     ).
    </li>
    <li>
     <strong>
      Intersecciones (
      <code>
       &amp;
      </code>
      ):
     </strong>
     Para combinar propiedades de objetos (ej.
     <code>
      Producto
     </code>
     ).
    </li>
    <li>
     <strong>
      Tuplas:
     </strong>
     Arrays con longitud fija y tipos predefinidos por posición (ej.
     <code>
      Dinero
     </code>
     ).
    </li>
    <li>
     <strong>
      Tuplas
      <code>
       readonly
      </code>
      :
     </strong>
     Para asegurar que los elementos de la tupla no se modifiquen después de la creación.
    </li>
    <li>
     <strong>
      Tipos de Cadena Literal de Plantilla:
     </strong>
     Para definir patrones de cadenas (ej.
     <code>
      SKU
     </code>
     ).
    </li>
    <li>
     <strong>
      Discriminadores:
     </strong>
     Propiedades literales que permiten a TypeScript reducir el tipo de una unión (ej.
     <code>
      kind
     </code>
     en
     <code>
      EstadoProducto
     </code>
     ).
    </li>
    <li>
     <strong>
      Guards de Tipo (
      <code>
       is Type
      </code>
      ):
     </strong>
     Funciones que le indican a TypeScript cuándo un valor es de un tipo más específico.
    </li>
    <li>
     <strong>
      Desestructuración:
     </strong>
     Para extraer valores de objetos o arrays/tuplas fácilmente.
    </li>
   </ul>
   <p>
    <strong>
     Ejecuta
    </strong>
    :
   </p>
   <div class="highlight language-bash">
    <pre><span></span>npm<span class="w"> </span>run<span class="w"> </span>typecheck
npm<span class="w"> </span>run<span class="w"> </span>dev<span class="w"> </span>--<span class="w"> </span>src/02-modelado.ts
</pre>
   </div>
   <blockquote>
    <p>
     Si tu script
     <code>
      dev
     </code>
     no acepta ruta, usa
     <code>
      ts-node src/02-modelado.ts
     </code>
     o crea un script
     <code>
      "dev:file": "ts-node"
     </code>
     y ejecuta
     <code>
      npm run dev:file src/02-modelado.ts
     </code>
     .
    </p>
   </blockquote>
   <h4 id="22-tuplas-y-readonly-src02-tuplasts">
    2.2 Tuplas y
    <code>
     readonly
    </code>
    (
    <code>
     src/02-tuplas.ts
    </code>
    )
   </h4>
   <p>
    <strong>
     Objetivo
    </strong>
    : forzar posiciones y evitar mutaciones accidentales.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="k">export</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="nx">Coordenada</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">readonly</span><span class="w"> </span><span class="p">[</span><span class="nx">lat</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="nx">lon</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">]</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">casa</span><span class="o">:</span><span class="w"> </span><span class="kt">Coordenada</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="o">-</span><span class="mf">38.72</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">62.27</span><span class="w"> </span><span class="p">]</span>
<span class="c1">// casa[0] = 0 // Error: readonly</span>

<span class="c1">// ejemplo de zip con tuplas</span>
<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">zip</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="kt">readonly</span><span class="w"> </span><span class="nx">T</span><span class="p">[],</span><span class="w"> </span><span class="nx">b</span><span class="o">:</span><span class="w"> </span><span class="kt">readonly</span><span class="w"> </span><span class="nx">U</span><span class="p">[])</span><span class="o">:</span><span class="w"> </span><span class="nx">ReadonlyArray</span><span class="o">&lt;</span><span class="k">readonly</span><span class="w"> </span><span class="p">[</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">U</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">r</span><span class="o">:</span><span class="w"> </span><span class="kt">Array</span><span class="o">&lt;</span><span class="k">readonly</span><span class="w"> </span><span class="p">[</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="nx">U</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">len</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="nx">r</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="w"> </span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="kd">const</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">r</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <h4 id="23-enum-vs-union-de-literales-src02-enum-unionts">
    2.3
    <code>
     enum
    </code>
    vs unión de literales (
    <code>
     src/02-enum-union.ts
    </code>
    )
   </h4>
   <p>
    <strong>
     Objetivo
    </strong>
    : comparar ergonomía y
    <em>
     DX
    </em>
    .
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="c1">// Unión de literales</span>
<span class="k">export</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="nx">Rol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"admin"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">"editor"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">"viewer"</span>

<span class="c1">// enum (alternativa)</span>
<span class="k">export</span><span class="w"> </span><span class="kd">enum</span><span class="w"> </span><span class="nx">RolEnum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">Admin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"admin"</span><span class="p">,</span><span class="w"> </span><span class="nx">Editor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"editor"</span><span class="p">,</span><span class="w"> </span><span class="nx">Viewer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"viewer"</span><span class="w"> </span><span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">puedeEditar</span><span class="p">(</span><span class="nx">r</span><span class="o">:</span><span class="w"> </span><span class="kt">Rol</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">RolEnum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">typeof</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"string"</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">r.toString</span><span class="p">()</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"admin"</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"editor"</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <h4 id="24-predicados-y-exhaustiveness-src02-guardsts">
    2.4 Predicados y
    <em>
     exhaustiveness
    </em>
    (
    <code>
     src/02-guards.ts
    </code>
    )
   </h4>
   <p>
    <strong>
     Objetivo
    </strong>
    : usar
    <em>
     type predicates
    </em>
    y chequeo exhaustivo.
   </p>
   <div class="highlight language-ts">
    <div class="collapsible-container" data-max-lines="6">
     <pre><span></span><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">EstadoProducto</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">"./02-modelado"</span>

<span class="kr">type</span><span class="w"> </span><span class="nx">Cargado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">k</span><span class="o">:</span><span class="w"> </span><span class="s2">"ok"</span><span class="p">;</span><span class="w"> </span><span class="nx">data</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[]</span><span class="w"> </span><span class="p">}</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Cargando</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">k</span><span class="o">:</span><span class="w"> </span><span class="s2">"load"</span><span class="w"> </span><span class="p">}</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">ErrorNet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">k</span><span class="o">:</span><span class="w"> </span><span class="s2">"err"</span><span class="p">;</span><span class="w"> </span><span class="nx">msg</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">}</span>

<span class="kr">type</span><span class="w"> </span><span class="nx">Estado</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Cargado</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Cargando</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">ErrorNet</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">esCargado</span><span class="p">(</span><span class="nx">e</span><span class="o">:</span><span class="w"> </span><span class="kt">Estado</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">Cargado</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">e</span><span class="p">.</span><span class="nx">k</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"ok"</span><span class="w"> </span><span class="p">}</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">assertNever</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">never</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">never</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">"Estado desconocido: "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span><span class="w"> </span><span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">render</span><span class="p">(</span><span class="nx">e</span><span class="o">:</span><span class="w"> </span><span class="kt">Estado</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">esCargado</span><span class="p">(</span><span class="nx">e</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="sb">`items: </span><span class="si">${</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="si">}</span><span class="sb">`</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">k</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"load"</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s2">"cargando…"</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">k</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s2">"err"</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="sb">`error: </span><span class="si">${</span><span class="nx">e</span><span class="p">.</span><span class="nx">msg</span><span class="si">}</span><span class="sb">`</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">assertNever</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="c1">// fuerza exhaustividad</span>
<span class="p">}</span>
</pre>
    </div>
   </div>
   <hr/>
   <h3 id="3-ejercicios-opcionales">
    3) Ejercicios opcionales
   </h3>
   <ol>
    <li>
     <strong>
      <code>
       type
      </code>
      vs
      <code>
       interface
      </code>
     </strong>
     : modela
     <code>
      Usuario
     </code>
     con ambos; extiende
     <code>
      interface
     </code>
     vía
     <em>
      merging
     </em>
     y crea un
     <code>
      type
     </code>
     unión
     <code>
      Activo | Suspendido
     </code>
     .
    </li>
    <li>
     <strong>
      Discriminated union
     </strong>
     :
     <code>
      Pago
     </code>
     con
     <code>
      { kind: "cash"|"card"|"mp" }
     </code>
     y funciones que procesen cada caso con
     <em>
      exhaustiveness
     </em>
     .
    </li>
    <li>
     <strong>
      Tuplas/readonly
     </strong>
     : define
     <code>
      RangoFechas = readonly [inicio: Date, fin: Date]
     </code>
     y valida orden.
    </li>
    <li>
     <strong>
      Narrowing
     </strong>
     : implementa
     <code>
      safeLength(x: string | { length: number } | null): number
     </code>
     sin usar
     <code>
      !
     </code>
     .
    </li>
    <li>
     <strong>
      Enum vs unión
     </strong>
     : representa roles
     <code>
      admin/editor/viewer
     </code>
     de dos formas y comenta pros/contras en README.
    </li>
   </ol>
   <hr/>
   <h3 id="4-comandos-utiles">
    4) Comandos útiles
   </h3>
   <div class="highlight language-bash">
    <pre><span></span>npm<span class="w"> </span>run<span class="w"> </span>typecheck
npm<span class="w"> </span>run<span class="w"> </span>dev<span class="w"> </span>--<span class="w"> </span>src/02-modelado.ts
npm<span class="w"> </span>run<span class="w"> </span>dev<span class="w"> </span>--<span class="w"> </span>src/02-tuplas.ts
npm<span class="w"> </span>run<span class="w"> </span>dev<span class="w"> </span>--<span class="w"> </span>src/02-enum-union.ts
npm<span class="w"> </span>run<span class="w"> </span>dev<span class="w"> </span>--<span class="w"> </span>src/02-guards.ts
</pre>
   </div>
  </div>
  <textarea id="css-editor" style="display:none;">pre {line-height: 125%;}

td.linenos .normal {color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px;}

span.linenos {color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px;}

td.linenos .special {color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px;}

span.linenos.special {color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px;}

.highlight .hll {background-color: #ffffcc;}

.highlight {background: #f8f8f8; padding: 0; border-radius: 5px; margin: 15px 0; background-color: #fef6e4 !important; border: 1px solid #f0e6d4; box-shadow: 0 1px 3px rgba(0,0,0,0.1);}

.highlight .c {color: #9a8052 !important; font-style: italic;}

/* Comment */
.highlight .err {border: 1px solid #F00;}

/* Error */
.highlight .k {color: #008000; font-weight: bold;}

/* Keyword */
.highlight .o {color: #666;}

/* Operator */
.highlight .ch {color: #3D7B7B; font-style: italic;}

/* Comment.Hashbang */
.highlight .cm {color: #3D7B7B; font-style: italic;}

/* Comment.Multiline */
.highlight .cp {color: #9C6500;}

/* Comment.Preproc */
.highlight .cpf {color: #3D7B7B; font-style: italic;}

/* Comment.PreprocFile */
.highlight .c1 {color: #3D7B7B; font-style: italic;}

/* Comment.Single */
.highlight .cs {color: #3D7B7B; font-style: italic;}

/* Comment.Special */
.highlight .gd {color: #A00000;}

/* Generic.Deleted */
.highlight .ge {font-style: italic;}

/* Generic.Emph */
.highlight .ges {font-weight: bold; font-style: italic;}

/* Generic.EmphStrong */
.highlight .gr {color: #E40000;}

/* Generic.Error */
.highlight .gh {color: #000080; font-weight: bold;}

/* Generic.Heading */
.highlight .gi {color: #008400;}

/* Generic.Inserted */
.highlight .go {color: #717171;}

/* Generic.Output */
.highlight .gp {color: #000080; font-weight: bold;}

/* Generic.Prompt */
.highlight .gs {font-weight: bold;}

/* Generic.Strong */
.highlight .gu {color: #800080; font-weight: bold;}

/* Generic.Subheading */
.highlight .gt {color: #04D;}

/* Generic.Traceback */
.highlight .kc {color: #008000; font-weight: bold;}

/* Keyword.Constant */
.highlight .kd {color: #008000; font-weight: bold;}

/* Keyword.Declaration */
.highlight .kn {color: #008000; font-weight: bold;}

/* Keyword.Namespace */
.highlight .kp {color: #008000;}

/* Keyword.Pseudo */
.highlight .kr {color: #008000; font-weight: bold;}

/* Keyword.Reserved */
.highlight .kt {color: #B00040;}

/* Keyword.Type */
.highlight .m {color: #666;}

/* Literal.Number */
.highlight .s {color: #BA2121;}

/* Literal.String */
.highlight .na {color: #687822;}

/* Name.Attribute */
.highlight .nb {color: #008000;}

/* Name.Builtin */
.highlight .nc {color: #00F; font-weight: bold;}

/* Name.Class */
.highlight .no {color: #800;}

/* Name.Constant */
.highlight .nd {color: #A2F;}

/* Name.Decorator */
.highlight .ni {color: #717171; font-weight: bold;}

/* Name.Entity */
.highlight .ne {color: #CB3F38; font-weight: bold;}

/* Name.Exception */
.highlight .nf {color: #00F;}

/* Name.Function */
.highlight .nl {color: #767600;}

/* Name.Label */
.highlight .nn {color: #00F; font-weight: bold;}

/* Name.Namespace */
.highlight .nt {color: #008000; font-weight: bold;}

/* Name.Tag */
.highlight .nv {color: #19177C;}

/* Name.Variable */
.highlight .ow {color: #A2F; font-weight: bold;}

/* Operator.Word */
.highlight .w {color: #BBB;}

/* Text.Whitespace */
.highlight .mb {color: #666;}

/* Literal.Number.Bin */
.highlight .mf {color: #666;}

/* Literal.Number.Float */
.highlight .mh {color: #666;}

/* Literal.Number.Hex */
.highlight .mi {color: #666;}

/* Literal.Number.Integer */
.highlight .mo {color: #666;}

/* Literal.Number.Oct */
.highlight .sa {color: #BA2121;}

/* Literal.String.Affix */
.highlight .sb {color: #BA2121;}

/* Literal.String.Backtick */
.highlight .sc {color: #BA2121;}

/* Literal.String.Char */
.highlight .dl {color: #BA2121;}

/* Literal.String.Delimiter */
.highlight .sd {color: #BA2121; font-style: italic;}

/* Literal.String.Doc */
.highlight .s2 {color: #BA2121;}

/* Literal.String.Double */
.highlight .se {color: #AA5D1F; font-weight: bold;}

/* Literal.String.Escape */
.highlight .sh {color: #BA2121;}

/* Literal.String.Heredoc */
.highlight .si {color: #A45A77; font-weight: bold;}

/* Literal.String.Interpol */
.highlight .sx {color: #008000;}

/* Literal.String.Other */
.highlight .sr {color: #A45A77;}

/* Literal.String.Regex */
.highlight .s1 {color: #BA2121;}

/* Literal.String.Single */
.highlight .ss {color: #19177C;}

/* Literal.String.Symbol */
.highlight .bp {color: #008000;}

/* Name.Builtin.Pseudo */
.highlight .fm {color: #00F;}

/* Name.Function.Magic */
.highlight .vc {color: #19177C;}

/* Name.Variable.Class */
.highlight .vg {color: #19177C;}

/* Name.Variable.Global */
.highlight .vi {color: #19177C;}

/* Name.Variable.Instance */
.highlight .vm {color: #19177C;}

/* Name.Variable.Magic */
.highlight .il {color: #666;}

body {font-family: Arial, sans-serif; line-height: 1.6; margin: 0 auto; padding: 20px;}

#main-title-block {background-color: #2e2e2e; color: #f0f0f0; padding: 18px; border-radius: 10px; border: 1px solid #444; box-shadow: 0 2px 5px rgba(0,0,0,0.2); font-size: 1.8em; font-weight: bold; margin-bottom: 20px; text-align: center;}

pre:not(.highlight pre) {background-color: #fef6e4; color: #2e2e2e; padding: 12px; border-radius: 5px; overflow-x: auto; border: 1px solid #f0e6d4; box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin: 15px 0;}

code {font-family: "Courier New", Courier, monospace;}

.highlight pre {background: none; border: none; box-shadow: none; padding: 12px; margin: 0; border-radius: 0;}

.highlight .c1 {color: #9a8052 !important; font-style: italic;}

.highlight .cm {color: #9a8052 !important; font-style: italic;}

.highlight .k {color: #8250df !important; font-weight: normal;}

.highlight .kd {color: #8250df !important; font-weight: normal;}

.highlight .kn {color: #8250df !important; font-weight: normal;}

.highlight .s {color: #327d41 !important;}

.highlight .s1 {color: #327d41 !important;}

.highlight .s2 {color: #327d41 !important;}

.highlight .sb {color: #327d41 !important;}

.highlight .si {color: #327d41 !important;}

.highlight .m {color: #606060 !important;}

.highlight .mi {color: #606060 !important;}

.highlight .mf {color: #606060 !important;}

.highlight .o {color: #666666 !important; font-weight: normal;}

.highlight .ow {color: #666666 !important; font-weight: normal;}

.highlight .kc {color: #9a5b13 !important;}

.highlight .no {color: #9a5b13 !important;}

.highlight .nf {color: #606060 !important; font-weight: normal;}

.highlight .nb {color: #606060 !important; font-weight: normal;}

.highlight .nx {color: #606060 !important; font-weight: normal;}

.highlight .p {color: #666666 !important; font-weight: normal;}

.language-jsx .highlight .k {color: #af00db !important; font-weight: normal; background: none !important; border: none !important;}

.language-jsx .highlight .kd {color: #af00db !important; font-weight: normal; background: none !important; border: none !important;}

.language-jsx .highlight .kr {color: #af00db !important; font-weight: normal; background: none !important; border: none !important;}

.language-jsx .highlight .nx {color: #0969da !important; background: none !important; border: none !important;}

.language-jsx .highlight .nf {color: #0969da !important; background: none !important; border: none !important;}

.language-jsx .highlight .nt {color: #116329 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-jsx .highlight .nc {color: #116329 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-jsx .highlight .o {color: #666666 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-jsx .highlight .p {color: #666666 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-jsx .highlight .na {color: #0969da !important; background: none !important; border: none !important;}

.language-jsx .highlight .s {color: #0a3069 !important; background: none !important; border: none !important;}

.language-jsx .highlight .s1 {color: #0a3069 !important; background: none !important; border: none !important;}

.language-jsx .highlight .s2 {color: #0a3069 !important; background: none !important; border: none !important;}

.language-jsx .highlight .c {color: #656d76 !important; font-style: italic; background: none !important; border: none !important;}

.language-jsx .highlight .c1 {color: #656d76 !important; font-style: italic; background: none !important; border: none !important;}

.language-jsx .highlight .cm {color: #656d76 !important; font-style: italic; background: none !important; border: none !important;}

.language-jsx .highlight .m {color: #0969da !important; background: none !important; border: none !important;}

.language-jsx .highlight .mi {color: #0969da !important; background: none !important; border: none !important;}

.language-jsx .highlight .mf {color: #0969da !important; background: none !important; border: none !important;}

.language-react .highlight .k {color: #af00db !important; font-weight: normal; background: none !important; border: none !important;}

.language-react .highlight .kd {color: #af00db !important; font-weight: normal; background: none !important; border: none !important;}

.language-react .highlight .kr {color: #af00db !important; font-weight: normal; background: none !important; border: none !important;}

.language-react .highlight .nx {color: #0969da !important; background: none !important; border: none !important;}

.language-react .highlight .nf {color: #0969da !important; background: none !important; border: none !important;}

.language-react .highlight .nt {color: #116329 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-react .highlight .nc {color: #116329 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-react .highlight .o {color: #666666 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-react .highlight .p {color: #666666 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-react .highlight .na {color: #0969da !important; background: none !important; border: none !important;}

.language-react .highlight .s {color: #0a3069 !important; background: none !important; border: none !important;}

.language-react .highlight .s1 {color: #0a3069 !important; background: none !important; border: none !important;}

.language-react .highlight .s2 {color: #0a3069 !important; background: none !important; border: none !important;}

.language-react .highlight .c {color: #656d76 !important; font-style: italic; background: none !important; border: none !important;}

.language-react .highlight .c1 {color: #656d76 !important; font-style: italic; background: none !important; border: none !important;}

.language-react .highlight .cm {color: #656d76 !important; font-style: italic; background: none !important; border: none !important;}

.language-react .highlight .m {color: #0969da !important; background: none !important; border: none !important;}

.language-react .highlight .mi {color: #0969da !important; background: none !important; border: none !important;}

.language-react .highlight .mf {color: #0969da !important; background: none !important; border: none !important;}

.language-tsx .highlight .k {color: #af00db !important; font-weight: normal; background: none !important; border: none !important;}

.language-tsx .highlight .kd {color: #af00db !important; font-weight: normal; background: none !important; border: none !important;}

.language-tsx .highlight .kr {color: #af00db !important; font-weight: normal; background: none !important; border: none !important;}

.language-tsx .highlight .nx {color: #0969da !important; background: none !important; border: none !important;}

.language-tsx .highlight .nf {color: #0969da !important; background: none !important; border: none !important;}

.language-tsx .highlight .nt {color: #116329 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-tsx .highlight .nc {color: #116329 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-tsx .highlight .o {color: #666666 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-tsx .highlight .p {color: #666666 !important; background: none !important; border: none !important; box-shadow: none !important; outline: none !important;}

.language-tsx .highlight .na {color: #0969da !important; background: none !important; border: none !important;}

.language-tsx .highlight .s {color: #0a3069 !important; background: none !important; border: none !important;}

.language-tsx .highlight .s1 {color: #0a3069 !important; background: none !important; border: none !important;}

.language-tsx .highlight .s2 {color: #0a3069 !important; background: none !important; border: none !important;}

.language-tsx .highlight .c {color: #656d76 !important; font-style: italic; background: none !important; border: none !important;}

.language-tsx .highlight .c1 {color: #656d76 !important; font-style: italic; background: none !important; border: none !important;}

.language-tsx .highlight .cm {color: #656d76 !important; font-style: italic; background: none !important; border: none !important;}

.language-tsx .highlight .m {color: #0969da !important; background: none !important; border: none !important;}

.language-tsx .highlight .mi {color: #0969da !important; background: none !important; border: none !important;}

.language-tsx .highlight .mf {color: #0969da !important; background: none !important; border: none !important;}

.language-tsx .highlight .kt {color: #0969da !important; background: none !important; border: none !important;}

.language-javascript .highlight .err {color: #116329 !important; background: none !important; border: none !important;}

.language-js .highlight .err {color: #116329 !important; background: none !important; border: none !important;}

.highlight span {background: none !important; border: none !important; box-shadow: none !important; text-decoration: none !important; outline: none !important;}

.empty-code-block {background-color: #fef6e4; color: #2e2e2e; padding: 12px; border-radius: 5px; margin: 15px 0; font-family: monospace; border: 1px solid #f0e6d4; box-shadow: 0 1px 3px rgba(0,0,0,0.1);}

.highlight-error {background-color: #fef6e4; color: #000080; padding: 12px; border-radius: 5px; margin: 15px 0; font-family: monospace; border: 1px solid #f0e6d4; box-shadow: 0 1px 3px rgba(0,0,0,0.1);}

img {max-width: 100%; height: auto;}

table {border-collapse: collapse; width: 100%;}

th {border: 1px solid #ddd; padding: 8px; background-color: #f2f2f2;}

td {border: 1px solid #ddd; padding: 8px;}

.chapter-container {background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);}

.chapter-container h2 {margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; color: #444;}

/* Estilos para el contenedor colapsable */
.collapsible-container {position: relative; overflow: hidden; transition: max-height 0.3s ease; border-radius: 8px; margin: 0;}

.collapsible-container pre {margin: 0; line-height: 1.4;}

.collapsible-container .toggle-button {position: absolute; top: 8px; right: 8px; background: rgba(255,255,255,0.9); border: 1px solid #ccc; cursor: pointer; font-size: 16px; line-height: 1; padding: 4px 8px; border-radius: 4px; z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.1);}

.collapsible-container .toggle-button:hover {background: rgba(255,255,255,1);}

/* Estilos para el botón de copiar */
.collapsible-container .copy-button {position: absolute; top: 8px; width: 24px; display: flex; /* Usamos flexbox para centrar el icono/texto */
  align-items: center; justify-content: center; right: 48px; /* A 40 px a la izquierda del botón de colapsar */
  background: rgba(255,255,255,0.9); border: 1px solid #ccc; cursor: pointer; font-size: 16px; line-height: 1; padding: 4px 8px; border-radius: 4px; z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.1);}

.collapsible-container .copy-button:hover {background: rgba(255,255,255,1);}

.collapsible-container .fade-overlay {position: absolute; bottom: -1px; left: 0; right: 0; height: 42px; background: linear-gradient(
    to bottom, 
    rgba(255,249,229,0), 
    rgba(255,249,229,1)
  ); pointer-events: none; z-index: 5; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px;}

.collapsible-container .ellipsis {position: absolute; bottom: 8px; width: 100%; text-align: center; color: #888; font-size: 18px; font-weight: bold; z-index: 6;}

.collapsible-container.expanded .fade-overlay {display: none;}

.collapsible-container.expanded .ellipsis {display: none;}

/* Estilos para la tabla de contenidos */

/* Contenedor principal */
#table-of-contents {background-color: #f0f0ff; border-radius: 8px; padding: 20px 30px; margin: 20px 0; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05); font-family: Arial, sans-serif; border: 1px solid #d0d0ff;}

/* Título de la tabla de contenidos */
#contents-header {text-align: center; color: #585b9e; font-size: 24px; margin-top: 10px; margin-bottom: 20px; font-weight: 500; padding-bottom: 15px;}

/* Listas */
ul.toc {list-style-type: none; padding-left: 20px; margin: 0;}

/* Elementos de la lista */
li.toc {margin: 10px 0; line-height: 1.5; color: #585b9e;}

/* Enlaces */
a.toc {text-decoration: none; color: #585b9e; transition: color 0.2s, padding-left 0.2s; display: inline-block;}

/* Efecto hover en los enlaces */
a.toc:hover {color: #3333cc; padding-left: 3px; font-weight: 500; text-decoration: none;}

/* Diferentes niveles de indentación */
li.toc li.toc {margin-left: 15px;}

li.toc li.toc li.toc {margin-left: 25px;}

/* Hacer que los enlaces de primer nivel tengan un poco más de peso */
ul.toc &gt; li.toc &gt; a.toc {font-weight: 500;}

/* Línea decorativa sobre la tabla de contenidos */
#table-of-contents:before {content: ""; display: block; height: 0px; background-color: #d0d0ff; margin-bottom: 15px;}</textarea>
  <script>
   document.addEventListener('DOMContentLoaded', function() {
    var cssCode = document.getElementById('css-editor').value;
    var style = document.createElement('style');
    style.textContent = cssCode;
    document.head.appendChild(style);
});
  </script>
  <script>
   document.addEventListener('DOMContentLoaded', function() {
    // Aplicar estilo con retraso de 100ms para superar posibles hojas de estilo heredadas
    setTimeout(function() {
        document.querySelectorAll('.toggle-button').forEach(btn => {
            btn.style.setProperty('color', 'black', 'important');
            if (!btn.textContent.trim()) {
                btn.textContent = '+';
            }
        });
        document.querySelectorAll('.copy-button').forEach(btn => {
            btn.style.setProperty('color', 'black', 'important');
        });
    }, 1000);
});
  </script>
  <script>
   document.addEventListener('DOMContentLoaded', function() {
(function() {
  function initCollapsibles() {
    // Esperar un poco para que los estilos se apliquen
    setTimeout(() => {
      document.querySelectorAll('.collapsible-container').forEach(container => {
        const pre = container.querySelector('pre');
        if (!pre) return;
        
        const maxLines = parseInt(container.dataset.maxLines, 10) || 6;
        
        // Crear un elemento temporal para medir line-height
        const tempSpan = document.createElement('span');
        tempSpan.style.visibility = 'hidden';
        tempSpan.style.position = 'absolute';
        tempSpan.style.fontSize = getComputedStyle(pre).fontSize;
        tempSpan.style.fontFamily = getComputedStyle(pre).fontFamily;
        tempSpan.style.lineHeight = '1.4';
        tempSpan.textContent = 'M';
        document.body.appendChild(tempSpan);
        
        const lineHeight = tempSpan.offsetHeight;
        document.body.removeChild(tempSpan);
        
        const fullHeight = pre.scrollHeight;
        const collapsedHeight = Math.ceil(lineHeight * maxLines);
        
        console.log('Debug:', {
          maxLines,
          lineHeight,
          fullHeight,
          collapsedHeight,
          shouldCollapse: fullHeight > collapsedHeight + 10
        });
        
        // Solo colapsar si realmente es necesario
        if (fullHeight <= collapsedHeight + 10) {
          return;
        }

        // Estado inicial: colapsado
        container.style.maxHeight = collapsedHeight + 'px';
        container.classList.add('collapsed');

         // === Aquí agregamos primero el botón de "copiar" ===
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-button';
        copyBtn.innerHTML = '📋';
        copyBtn.title = 'Copiar código';
        container.appendChild(copyBtn);

        // Evento para copiar el texto del <pre> al portapapeles
        copyBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          // Copiar el contenido de 'pre'
          const codeText = pre.innerText;
          navigator.clipboard.writeText(codeText).then(() => {
            // Opcional: retroalimentación breve (por ejemplo cambiar texto o color)
            copyBtn.textContent = '✔';
            setTimeout(() => { copyBtn.innerHTML = '📋'; }, 1000);
          }).catch(err => {
            console.error('Error al copiar al portapapeles:', err);
          });
        });

        // Crear botón
        const btn = document.createElement('button');
        btn.className = 'toggle-button';
        btn.textContent = '+';
        btn.title = 'Expandir/Colapsar código';
        container.appendChild(btn);

        // Crear overlay y ellipsis
        const overlay = document.createElement('div');
        overlay.className = 'fade-overlay';
        container.appendChild(overlay);
        
        const ell = document.createElement('div');
        ell.className = 'ellipsis';
        ell.textContent = '...';
        container.appendChild(ell);

        // Evento toggle
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          const isCollapsed = container.classList.contains('collapsed');
          
          if (isCollapsed) {
            // Expandir
            container.style.maxHeight = fullHeight + 20 + 'px';
            container.classList.remove('collapsed');
            container.classList.add('expanded');
            btn.textContent = '−';
          } else {
            // Colapsar
            container.style.maxHeight = collapsedHeight + 'px';
            container.classList.add('collapsed');
            container.classList.remove('expanded');
            btn.textContent = '+';
          }
        });
      });
    }, 100); // Esperar 100ms para que se apliquen los estilos
  }
  
  // Múltiples puntos de inicialización para mayor compatibilidad
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCollapsibles);
  } else {
    initCollapsibles();
  }
  
  // También inicializar en window.load por si acaso
  window.addEventListener('load', initCollapsibles);
})();
});
  </script>
 </body>
</html>
